const cds = require('../cds'),
  { Object_keys, results } = cds.utils
const LOG = cds.log('fiori|drafts')

const DRAFT_ELEMENTS = new Set([
  'IsActiveEntity',
  'HasDraftEntity',
  'HasActiveEntity',
  'DraftAdministrativeData',
  'DraftAdministrativeData_DraftUUID',
  'SiblingEntity'
])

const REDUCED_DRAFT_ELEMENTS = new Set(['IsActiveEntity', 'HasDraftEntity', 'SiblingEntity'])

const DRAFT_ADMIN_ELEMENTS = [
  'DraftUUID',
  'LastChangedByUser',
  'CreatedByUser',
  'InProcessByUser',
  'DraftIsCreatedByMe',
  'DraftIsProcessedByMe'
]

const DRAFT_CANCEL_TIMEOUT_IN_MIN = () =>
  (cds.env.drafts?.cancellationTimeout && Number(cds.env.drafts?.cancellationTimeout)) || 15

const h = cds.ApplicationService.prototype.handle
cds.ApplicationService.prototype.handle = function (req) {
  const handle = h.bind(this)

  const _newReq = (req, query) => {
    // REVISIT: This is a bit hacky -> better way?
    query._target = undefined
    cds.infer(query, this.model.definitions)
    const _req = cds.Request.for(req._) // REVISIT: this causes req._.data of WRITE reqs copied to READ reqs
    if (query.SELECT) delete _req.data // which we fix here -> but this is an ugly workaround
    _req.query = query
    _req.event = req.event
    _req.target = query._target
    _req._.params = req.params
    _req._.query = query
    _req._ = req._
    return _req
  }

  if (!req.query || req.query._draftParams) return handle(req)
  const query = _cleansed(req.query, this.model)
  const draftParams = query._draftParams
  if (req.event !== 'READ') {
    const _req = _newReq(req, query)
    return handle(_req)
  }

  const read =
    draftParams.IsActiveEntity === false && draftParams.SiblingEntity_IsActiveEntity === null
      ? Read.all
      : draftParams.IsActiveEntity === true &&
        draftParams.SiblingEntity_IsActiveEntity === null &&
        draftParams.DraftAdministrativeData_InProcessByUser === 'not null'
      ? Read.lockedByAnotherUser
      : draftParams.IsActiveEntity === true &&
        draftParams.SiblingEntity_IsActiveEntity === null &&
        draftParams.DraftAdministrativeData_InProcessByUser === ''
      ? Read.unsavedChangesByAnotherUser
      : draftParams.IsActiveEntity === true && draftParams.HasDraftEntity === false
      ? Read.unchanged
      : draftParams.IsActiveEntity === true
      ? Read.onlyActives
      : draftParams.IsActiveEntity === false
      ? Read.ownDrafts
      : Read.onlyActives
  const run = async query => {
    const _req = _newReq(req, query)
    return handle(_req)
  }
  return read(run, query)
}

const Read = {
  onlyActives: async function (run, query, { ignoreDrafts } = {}) {
    // DraftAdministrativeData is only accessible via drafts
    if (query._target.name.endsWith('.DraftAdministrativeData')) return run(query._drafts)
    const actives = await run(query)
    if (!actives || (Array.isArray(actives) && !actives.length) || !query._target.drafts) return actives
    let drafts
    if (ignoreDrafts) drafts = []
    else {
      try {
        drafts = await Read.complementaryDrafts(run, query, actives)
      } catch (e) {
        drafts = []
      }
    }
    Read.merge(query._target, actives, drafts, (row, other) =>
      other
        ? Object.assign(row, other, { IsActiveEntity: true, HasActiveEntity: false, HasDraftEntity: true })
        : Object.assign(row, {
            IsActiveEntity: true,
            HasActiveEntity: false,
            HasDraftEntity: false,
            DraftAdministrativeData: null,
            DraftAdministrativeData_DraftUUID: null
          })
    )
    return actives
  },
  unchanged: async function (run, query) {
    const draftsQuery = query._drafts
    const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
    draftsQuery.SELECT.count = undefined
    draftsQuery.SELECT.limit = undefined
    draftsQuery.SELECT.orderBy = undefined
    draftsQuery.SELECT.columns = keys.map(k => ({ ref: [k] }))

    const drafts = await run(draftsQuery)
    const res = Read.onlyActives(run, query.where(Read.whereNotIn(query._target, drafts)), {
      ignoreDrafts: true
    })
    return res
  },
  ownDrafts: async function (run, query) {
    if (!query._target.drafts) return run(query._drafts)
    const drafts = await run(
      query._drafts.where({ ref: ['DraftAdministrativeData', 'InProcessByUser'] }, '=', cds.context.user.id)
    )
    Read.merge(query._target, drafts, [], row =>
      Object.assign(row, {
        IsActiveEntity: false,
        HasDraftEntity: false
      })
    )
    return drafts
  },
  all: async function (run, query) {
    query._drafts.SELECT.count = true
    const drafts = await run(
      query._drafts.where({ ref: ['DraftAdministrativeData', 'InProcessByUser'] }, '=', cds.context.user.id)
    )

    const skip = query.SELECT.limit?.offset?.val
    const top = query.SELECT.limit?.rows?.val

    const appliedSkip = drafts.length ? skip : drafts.$count

    const topActives = top && Math.max(0, top - drafts.length)
    let actives
    if (topActives === 0) {
      actives = []
    } else {
      const skipActives = skip && skip - appliedSkip
      query.SELECT.count = true
      actives = await run(query.limit(topActives, skipActives).where(Read.whereNotIn(query._target, drafts)))
      const draftsFromActives = await Read.complementaryDrafts(run, query, actives)
      Read.merge(query._target, actives, draftsFromActives, (row, other) => {
        if (other) {
          Object.assign(row, other, {
            IsActiveEntity: true,
            HasDraftEntity: true,
            HasActiveEntity: false
          })
        } else {
          Object.assign(row, {
            IsActiveEntity: true,
            HasDraftEntity: false,
            HasActiveEntity: false,
            DraftAdministrativeData_DraftUUID: null,
            DraftAdministrativeData: null
          })
        }
      })
    }
    Read.merge(query._target, drafts, [], row =>
      Object.assign(row, {
        IsActiveEntity: false,
        HasDraftEntity: false
      })
    )
    const totalCount = actives.$count + drafts.$count
    const result = Object.assign([...drafts, ...actives], { $count: totalCount })
    return result
  },
  activesFromDrafts: async function (run, query, { isLocked = true }) {
    const draftsQuery = query._drafts
    const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
    const additionalCols = draftsQuery.SELECT.columns
      ? draftsQuery.SELECT.columns.filter(
          c => c.ref && ['DraftAdministrativeData', 'DraftAdministrativeData_DraftUUID'].includes(c.ref[0])
        )
      : [{ ref: ['DraftAdministrativeData_DraftUUID'] }]
    draftsQuery.SELECT.columns = keys.map(k => ({ ref: [k] })).concat(additionalCols)
    draftsQuery.where({
      HasActiveEntity: true,
      'DraftAdministrativeData.InProcessByUser': { '!=': cds.context.user.id },
      'DraftAdministrativeData.LastChangeDateTime': {
        [isLocked ? '>' : '<']: Read.lockshiftedNow
      }
    })
    const drafts = await run(draftsQuery)
    const actives = drafts.length
      ? await run(query.where(Read.whereIn(query._target, drafts)))
      : Object.assign([], { $count: 0 })
    Read.merge(query._target, actives, drafts, (row, other) =>
      other
        ? Object.assign(row, other, { IsActiveEntity: true, HasDraftEntity: true, HasActiveEntity: false })
        : Object.assign({ IsActiveEntity: true, HasDraftEntity: false, HasActiveEntity: false })
    )
    return actives
  },
  unsavedChangesByAnotherUser: async function (run, query) {
    return Read.activesFromDrafts(run, query, { isLocked: false })
  },
  lockedByAnotherUser: async function (run, query) {
    return Read.activesFromDrafts(run, query, { isLocked: true })
  },
  get lockshiftedNow() {
    return new Date(Date.now() - DRAFT_CANCEL_TIMEOUT_IN_MIN() * 60 * 1000).toISOString()
  },
  whereNotIn: (target, data) => Read.whereIn(target, data, true),
  whereIn: (target, data, not = false) => {
    const keys = Object_keys(target.keys).filter(k => k !== 'IsActiveEntity')
    const dataArray = data ? (Array.isArray(data) ? data : [data]) : []
    return [
      { list: keys.map(k => ({ ref: [k] })) },
      not ? 'not in' : 'in',
      { list: dataArray.map(r => ({ list: keys.map(k => ({ val: r[k] })) })) }
    ]
  },
  complementaryDrafts: (run, query, _actives) => {
    const actives = Array.isArray(_actives) ? _actives : [_actives]
    if (!actives.length) return []
    const drafts = cds.ql.clone(query._drafts)
    drafts.SELECT.where = Read.whereIn(query._target, actives)
    const relevantColumns = ['DraftAdministrativeData', 'DraftAdministrativeData_DraftUUID']
    drafts.SELECT.columns = (
      drafts.SELECT.columns?.filter(c => c.ref && relevantColumns.includes(c.ref[0])) ||
      relevantColumns.map(k => ({ ref: [k] }))
    ).concat(
      Object_keys(query._target.keys)
        .filter(k => k !== 'IsActiveEntity')
        .map(k => ({ ref: [k] }))
    )
    drafts.SELECT.count = undefined
    drafts.SELECT.one = undefined
    return run(drafts)
  },
  merge: (target, data, otherData, cb) => {
    if (!data) return
    const dataArray = Array.isArray(data) ? data : [data]
    if (!dataArray.length) return
    const otherDataArray = Array.isArray(otherData) ? otherData : otherData ? [otherData] : []
    if (otherDataArray.length) {
      const _keys = Object_keys(target.keys).filter(k => k !== 'IsActiveEntity')
      const _hash = row => _keys.map(k => row[k]).reduce((res, curr) => res + '|$|' + curr, '')
      const d2hash = new Map()
      for (const row of otherDataArray) d2hash.set(_hash(row), row)
      for (const row of dataArray) {
        const other = d2hash.get(_hash(row))
        cb(row, other)
      }
    } else {
      for (const row of dataArray) {
        cb(row, undefined)
      }
    }
  }
}

/**
 * Creates a clone of the query, cleanses and collects all draft parameters into ._draftParams.
 */
function _cleansed(query, model, target) {
  const draftParams = {} //> used to collect draft filter criteria
  const q = _cleanseQuery(query, draftParams)
  if (query.SELECT) {
    let cache
    const getDrafts = () => {
      if (cache) return cache
      const draftsQuery = _cleanseQuery(query, {}) // could just clone `q` but the latter is ruined by database layer
      const [root, ...tail] = draftsQuery.SELECT.from.ref
      const draft = model.definitions[root.id || root].drafts
      draftsQuery.SELECT.from = {
        ref: [root.id ? { ...root, id: draft.name } : draft.name, ...tail]
      }
      if (query.SELECT.columns && query._target.drafts)
        draftsQuery.SELECT.columns = query.SELECT.columns.filter(c => !REDUCED_DRAFT_ELEMENTS.has(c.ref?.[0]))

      if (draftsQuery._target.name.endsWith('.DraftAdministrativeData')) {
        draftsQuery.SELECT.columns = _tweakAdminCols(draftsQuery.SELECT.columns)
      } else if (q._target.drafts) {
        draftsQuery.SELECT.columns = _tweakAdminExpand(draftsQuery.SELECT.columns)
      }
      Object.defineProperty(draftsQuery, '_draftParams', { value: draftParams, enumerable: false })
      cache = draftsQuery
      return draftsQuery
    }
    Object.defineProperty(q, '_drafts', {
      get() {
        return getDrafts()
      }
    })
  }

  Object.defineProperty(q, '_draftParams', { value: draftParams, enumerable: false })
  return q

  function _cleanseQuery(query, draftParams) {
    const q = cds.ql.clone(query)

    const ref = q.SELECT?.from.ref || q.UPDATE?.entity.ref || q.INSERT?.into.ref || q.DELETE?.from.ref
    const cqn = q.SELECT || q.UPDATE || q.INSERT || q.DELETE

    if (ref) {
      const cleansedRef = ref.map(r => (r.where ? { ...r, where: _cleanseWhere(r.where, draftParams) } : r))
      if (q.SELECT) q.SELECT.from = { ...q.SELECT.from, ref: cleansedRef }
      else if (q.DELETE) q.DELETE.from = { ...q.DELETE.from, ref: cleansedRef }
      else if (q.UPDATE) q.UPDATE.entity = { ...q.UPDATE.entity, ref: cleansedRef }
      else if (q.INSERT) q.INSERT.into = { ...q.INSERT.into, ref: cleansedRef }

      const siblingIdx = cleansedRef.findIndex(r => r === 'SiblingEntity')
      if (siblingIdx !== -1) {
        cleansedRef.splice(siblingIdx, 1)
        draftParams.IsActiveEntity = !draftParams.IsActiveEntity
      }
    }

    if (cqn.where) cqn.where = _cleanseWhere(cqn.where, draftParams)
    if (cqn.columns) cqn.columns = q.SELECT.columns.filter(c => !DRAFT_ELEMENTS.has(c.ref?.[0]))
    if (cqn.orderBy) cqn.orderBy = _cleanseWhere(cqn.orderBy, {})

    return q
  }

  function _tweakAdminExpand(columns) {
    if (!columns) return columns
    return columns.map(col => {
      if (col.ref?.[0] === 'DraftAdministrativeData') {
        return { ...col, expand: _tweakAdminCols(col.expand) }
      }
      return col
    })
  }

  function _tweakAdminCols(columns) {
    if (!columns) columns = DRAFT_ADMIN_ELEMENTS.map(k => ({ ref: [k] }))
    return columns.map(col => {
      const name = col.ref?.[0]
      if (!name) return col
      switch (name) {
        case 'DraftAdministrativeData':
          return { ...col, expand: _tweakAdminCols(col.expand) }
        case 'DraftIsCreatedByMe':
          return {
            xpr: [
              'case',
              'when',
              { ref: ['CreatedByUser'] },
              '=',
              { val: cds.context.user.id },
              'then',
              { val: true },
              'else',
              { val: false },
              'end'
            ],
            as: 'DraftIsCreatedByMe',
            cast: { type: 'cds.Boolean' }
          }
        case 'InProcessByUser':
          return {
            xpr: [
              'case',
              'when',
              { ref: ['LastChangeDateTime'] },
              '<',
              { val: Read.lockshiftedNow },
              'then',
              { val: '' },
              'else',
              { ref: ['InProcessByUser'] },
              'end'
            ],
            as: 'InProcessByUser',
            cast: { type: 'cds.String' }
          }
        case 'DraftIsProcessedByMe':
          return {
            xpr: [
              'case',
              'when',
              { ref: ['InProcessByUser'] },
              '=',
              { val: cds.context.user.id },
              'then',
              { val: true },
              'else',
              { val: false },
              'end'
            ],
            as: 'DraftIsProcessedByMe',
            cast: { type: 'cds.Boolean' }
          }
        default:
          return col
      }
    })
  }

  function _cleanseWhere(xpr, draftParams) {
    const cleansed = []
    for (let i = 0; i < xpr.length; ++i) {
      let x = xpr[i],
        e = x.ref?.[0]
      if (DRAFT_ELEMENTS.has(e)) {
        let { val } = xpr[i + 2]
        draftParams[x.ref.join('_')] = xpr[i + 1] === '!=' ? 'not ' + val : val
        i += 3
        continue
      }
      if (x.xpr) {
        x = { xpr: _cleanseWhere(x.xpr, draftParams) }
        if (!x.xpr) {
          i += 1
          continue
        }
      }
      cleansed.push(x)
    }
    const last = cleansed[cleansed.length - 1]
    if (last === 'and' || last === 'or') cleansed.pop()
    if (cleansed.length) return cleansed
  }
}

function _draftIsLocked(LastChangeDateTime) {
  return DRAFT_CANCEL_TIMEOUT_IN_MIN() * 60 * 1000 > Date.now() - Date.parse(LastChangeDateTime)
}

async function onNewDraft(req) {
  LOG.debug('new draft')
  const isRoot = typeof req.query.INSERT.into === 'string'
  let DraftUUID
  if (isRoot) DraftUUID = cds.utils.uuid()
  else {
    const rootData = await SELECT.one(req.query.INSERT.into.ref[0].id + '.drafts', d => {
      d.DraftAdministrativeData_DraftUUID,
        d.DraftAdministrativeData(a => {
          a.LastChangeDateTime, a.InProcessByUser
        })
    }).where(req.query.INSERT.into.ref[0].where)
    if (!rootData) req.reject(404)
    if (
      !rootData.DraftAdministrativeData.InProcessByUser === req.user.id &&
      _draftIsLocked(rootData.DraftAdministrativeData.LastChangeDateTime)
    )
      req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER')
    DraftUUID = rootData.DraftAdministrativeData_DraftUUID
  }
  const timestamp = cds.context.timestamp.toISOString() // REVISIT: toISOString should be done on db layer
  const adminDataCQN = isRoot
    ? INSERT.into('DRAFT.DraftAdministrativeData').entries({
        DraftUUID,
        CreationDateTime: timestamp,
        CreatedByUser: req.user.id,
        LastChangeDateTime: timestamp,
        LastChangedByUser: req.user.id,
        DraftIsCreatedByMe: true, // Dummy values
        DraftIsProcessedByMe: true, // Dummy values
        InProcessByUser: req.user.id
      })
    : UPDATE('DRAFT.DraftAdministrativeData')
        .data({
          InProcessByUser: req.user.id,
          LastChangedByUser: req.user.id,
          LastChangeDateTime: timestamp
        })
        .where({ DraftUUID })

  const draftData = Object.assign(
    { DraftAdministrativeData_DraftUUID: DraftUUID, HasActiveEntity: false },
    req.query.INSERT.entries[0]
  )
  delete draftData.IsActiveEntity
  const draftCQN = INSERT.into(req.target.drafts).entries(draftData)

  // TODO: do this? req.query._draftParams.IsActiveEntity = false
  await Promise.all([adminDataCQN, draftCQN].map(cqn => cds.run(cqn)))
  req._.readAfterWrite = true
  return { ...draftData, IsActiveEntity: false }
}
exports.onNewDraft = onNewDraft

async function onDraftPrepare(req) {
  LOG.debug('prepare draft')

  const draftParams = req.query._draftParams
  const where = req.query.SELECT.from.ref[0].where
  if (req.query.SELECT.from.ref.length > 1 || draftParams.IsActiveEntity !== false) {
    req.reject(400, 'Action "draftPrepare" can only be called on the root draft entity')
  }

  const keys = Object_keys(req.target.keys).filter(k => k !== 'IsActiveEntity')
  const data = await SELECT.one
    .from(req.target.drafts, d => {
      d.DraftAdministrativeData(a => a.InProcessByUser)
    })
    .columns(keys)
    .where(where)
  if (!data) req.reject(404)
  if (data.DraftAdministrativeData.InProcessByUser !== req.user.id) req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER')
  delete data.DraftAdministrativeData
  return { ...data, IsActiveEntity: false }
}
exports.onDraftPrepare = onDraftPrepare

// This function is better defined on DB layer
function expandStarStar(target, recursion = new Map()) {
  const MAX_RECURSION_DEPTH = (cds.env.features.recursion_depth && Number(cds.env.features.recursion_depth)) || 4
  // TODO: Remove draftcolumns from payload
  const columns = []
  for (const el in target.elements) {
    const element = target.elements[el]
    if (!element.isAssociation && !DRAFT_ELEMENTS.has(el)) columns.push({ ref: [el] })
    if (!element.isComposition) continue
    const _key = target.name + ':' + el
    let cache = recursion.get(_key)
    if (!cache) cache = 1 && recursion.set(_key, cache)
    if (cache >= MAX_RECURSION_DEPTH) return
    columns.push({ ref: [el], expand: expandStarStar(element._target, recursion) })
  }
  return columns
}

async function onDraftEdit(req) {
  LOG.debug('edit active')
  const draftParams = req.query._draftParams
  const targetWhere = req.query.SELECT.from.ref[0].where

  if (draftParams.IsActiveEntity !== true) req.reject(400)

  const DraftUUID = cds.utils.uuid()

  const cols = expandStarStar(req.target)
  const _addDraftColumns = (target, columns) => {
    if (target.drafts) {
      columns.push({ val: true, as: 'HasActiveEntity' })
      columns.push({ val: DraftUUID, as: 'DraftAdministrativeData_DraftUUID' })
    }
    for (const col of columns) {
      if (col.expand) {
        const el = target.elements[col.ref[0]]
        _addDraftColumns(el._target, col.expand)
      }
    }
  }
  _addDraftColumns(req.target, cols)

  const [res, draftExists] = await Promise.all([
    SELECT.one.from(req.target).columns(cols).where(targetWhere),
    SELECT.one(req.target.drafts).columns('1 as _exists').where(targetWhere)
  ])
  if (!res) req.reject(404)
  if (draftExists) req.reject(409, 'DRAFT_ALREADY_EXISTS')

  const timestamp = cds.context.timestamp.toISOString() // REVISIT: toISOString should be done on db layer
  await INSERT.into('DRAFT.DraftAdministrativeData').entries({
    DraftUUID,
    CreationDateTime: timestamp,
    CreatedByUser: req.user.id,
    LastChangeDateTime: timestamp,
    LastChangedByUser: req.user.id,
    DraftIsCreatedByMe: true, // Dummy values
    DraftIsProcessedByMe: true, // Dummy values
    InProcessByUser: req.user.id
  })

  const targetDraft = req.target.drafts
  await INSERT.into(targetDraft).entries(res)

  // REVISIT: we need to use okra API here because it must be set in the batched request
  // status code must be set in handler to allow overriding for FE V2
  req?._?.odataRes.setStatusCode(201)

  return { ...res, IsActiveEntity: false } // REVISIT: Flatten?
}
exports.onDraftEdit = onDraftEdit

async function onDraftActivate(req) {
  LOG.debug('activate draft')
  // TODO: Read all drafts, send deep update/insert (based on HasActiveEntity, which should be fille with new!)
  // It would be great if we'd have a SELECT ** to deeply expand the entity (along compositions), that should
  // be implemented in expand implementation.
  const targetDraft = req.target.drafts
  const targetWhere = req.query.SELECT.from.ref[0].where
  const res = await SELECT.one
    .from(targetDraft)
    .columns(expandStarStar(targetDraft))
    .columns(['HasActiveEntity', 'DraftAdministrativeData_DraftUUID'])
    .where(targetWhere)
  const DraftAdministrativeData_DraftUUID = res.DraftAdministrativeData_DraftUUID
  delete res.DraftAdministrativeData_DraftUUID
  const HasActiveEntity = res.HasActiveEntity
  delete res.HasActiveEntity
  // TODO: Deep delete!
  await Promise.all([
    DELETE.from(targetDraft).where(targetWhere),
    DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: DraftAdministrativeData_DraftUUID })
  ])
  // TODO: Check for InProcessByUser

  let event, query
  if (HasActiveEntity) {
    query = UPDATE(req.target).data(res).where(targetWhere)
    event = 'UPDATE'
  } else {
    query = INSERT.into(req.target).entries(res)
    event = 'CREATE'
  }
  const r = new cds.Request({ event, query, data: res })
  const result = await this.dispatch(r)

  // REVISIT: we need to use okra API here because it must be set in the batched request
  // status code must be set in handler to allow overriding for FE V2
  req?._?.odataRes.setStatusCode(201)

  return Object.assign(result, { IsActiveEntity: true })
}
exports.onDraftActivate = onDraftActivate

async function onPatch(req) {
  LOG.debug('patch draft')
  const targetDraft = req.target.drafts
  const targetWhere = req.query.UPDATE.entity.ref[0].where
  const res = await SELECT.one.from(targetDraft).columns('DraftAdministrativeData_DraftUUID').where(targetWhere)
  if (!res) req.reject(404)
  await UPDATE('DRAFT.DraftAdministrativeData')
    .data({
      InProcessByUser: req.user.id,
      LastChangedByUser: req.user.id,
      LastChangeDateTime: new Date()
    })
    .where({ DraftUUID: res.DraftAdministrativeData_DraftUUID })

  const updateData = { ...req.data }
  delete updateData.IsActiveEntity
  await UPDATE(targetDraft).data(updateData).where(targetWhere)
  return req.data
}
exports.onPatch = onPatch

async function onDelete(req) {
  LOG.debug('delete')
  const targetDraft = req.target.drafts
  const draftParams = req.query._draftParams
  const targetWhere = req.query.DELETE.from.ref[0].where
  const res = await SELECT.one.from(targetDraft).columns('DraftAdministrativeData_DraftUUID').where(targetWhere)
  if (!res && draftParams.IsActiveEntity === false) req.reject(404)
  const deletes = !res
    ? []
    : [
        DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: res.DraftAdministrativeData_DraftUUID }),
        DELETE.from(targetDraft).where(targetWhere)
      ]
  if (draftParams.IsActiveEntity) deletes.push(DELETE.from(req.target).where(targetWhere))
  await Promise.all(deletes)
  return req.data
}
exports.onDelete = onDelete
