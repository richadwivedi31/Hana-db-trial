module.exports = Object.assign(cds_bind, {
    options: ['--to', '--on', '--profile', '--kind', '--output-file'],
    flags: ['--exec'],
    shortcuts: ['-2', '-n', '-p', '-k', '-o'],
    help: `
# SYNOPSIS

    *cds bind* <service> [<options>]
    *cds bind --exec* [--profile <profile>] [--] <command> <args ...>

    Binds the given service to a service instance by storing connection information in *.cdsrc-private.json*
    in your project directory. Credentials are not stored in the file but rather retrieved dynamically during *cds watch*.
    Use option *--output-file* to specify a different path or file.

    With *--exec* you can execute arbitrary commands with your service bindings. The service bindings are provided
    in the *VCAP_SERVICES* env variable to the command.

# OPTIONS

    *-2 | --to* <instance>[:<key>] | <service-binding> | <secret>
        bind to a given Cloud Foundry instance, Kubernetes service binding or Kubernetes secret.

    *-n | --on* cf | k8s
        bind to service on Cloud Foundry or Kubernetes, defaults to Cloud Foundry

    *-p | --profile* <profile>
        add the given profile, defaults to *hybrid*

    *-k | --kind* <kind>
        the kind of service

    *-o | --output-file* <path>
        save bindings to the given *.cdsrc.json* or *package.json* file. Default is *.cdsrc-private.json*.
        If *path* is a directory, then it will save it to the *.cdsrc.json* file in that directory.

# EXAMPLE

    cds bind --to my-hdi-container
    cds bind --to my-hdi-container,my-xsuaa
    cds bind uaa --to my-xsuaa:my-xsuaa-key --kind xsuaa --profile myprofile

    cds bind --to my-hdi-container --output-file .
    cds bind --to my-hdi-container --output-file package.json

    cds bind --to my-hdi-container --on k8s
`
});


const BindingResolver = require('../lib/bind/bindingResolver')

const { highlight, bold, info } = require('../lib/util/term');

const { determineKinds, getRequiresNameFromKind, execAndExit, checkIsJavaProject, platformText, bindingText, logger } = require('../lib/bind/bindingUtil');

async function cds_bind(args, options) {

    options.profile = parseProfile(options.profile);
    setProfile(options.profile);

    if (options.exec) {
        await cds_bind_exec(args, options)
        return;
    }

    if (!options.to) {
        throw new Error(`use option --to or -2 to specify the target instance, e.g. cds bind --to myInstance:myService`);
    }

    if (args.length > 1) {
        throw new Error(`Too many arguments: Please specify only one or no service.`);
    }

    const isJavaProject = await checkIsJavaProject(process.cwd());

    let serviceArg = args[0]
    const targets = options.to.split(/,/g);

    if (targets.length >= 2 && serviceArg) {
        throw new Error(`Service argument cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the service argument.`);
    }

    if (targets.length >= 2 && options.kind) {
        throw new Error(`The option '--kind' cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the '--kind' option.`);
    }

    let on;
    if (options.on === 'k8s' || options.on === 'kubernetes') {
        on = 'k8s';
    } else if (!options.on || options.on === 'cf' || options.on === 'cloudfoundry') {
        on = 'cf';
    } else {
        throw new Error(`Invalid value '${options.on}' for option --on.`);
    }

    const onText = { 'cf': 'Cloud Foundry', 'k8s': 'Kubernetes' }[on];
    logger.log(`Retrieving data from ${onText}...`);
    let resolvedServices

    try {
        resolvedServices = await Promise.all(targets.map(async target => {
            let binding;
            if (on === 'k8s') {
                binding = { type: on, name: target };
            } else if (on === 'cf') {
                const [instance, key] = target.split(/:/);
                binding = { type: on, instance, key };
            } else {
                throw new Error('Internal Error');
            }
            const resolvedService = await BindingResolver.resolveBinding(undefined, binding);
            resolvedService._target = target;
            delete resolvedService.credentials;
            resolvedService.binding.resolved = false;
            return resolvedService;
        }));
    } catch (error) {
        if (error.name === 'AxiosError') {
            const errors = error.response?.data?.errors ?? []
            const responseInfo = errors.map(e => `${e.title}: ${e.detail} (${e.code})`).join('  \n')
            const requestInfo = error.request?.path
            throw new Error(`${error.toString()}\nResponse: ${responseInfo}\nRequest:${requestInfo}}`)
        }
        throw error
    }

    if (options.kind) {
        resolvedServices.forEach(service => service.kind = options.kind);
    } else {
        determineKinds(resolvedServices);
    }

    for (const resolvedService of resolvedServices) {
        if (serviceArg) {
            resolvedService.name = serviceArg;
        } else if (resolvedService.kind) {
            resolvedService.name = getRequiresNameFromKind(resolvedService.binding.instance, resolvedService.kind);
        }

        let { kind, name, binding } = resolvedService;
        name = name ?? `custom-service:${binding.instance || binding.secret}`
        resolvedService.name = resolvedService.name ?? name
        const kindText = kind ? ` with kind ${highlight(kind)}` : ''
        const nameText = highlight(name)

        logger.log(`Binding ${nameText} to ${platformText(binding)} ${bindingText(binding, highlight)}${kindText}`);
    }

    // prepare for different providers
    const userCdsrcJsonStorageProvider = require('../lib/bind/userCdsrcJsonStorageProvider');

    await userCdsrcJsonStorageProvider.storeServices(resolvedServices, {
        ...options
    });

    logger.log(`${info('TIP:')} Run with cloud bindings: ${bold(runCmd(options, isJavaProject))}`);
}

async function cds_bind_exec(command) { // eslint-disable-lint
    const cds = require('../lib/cds');
    const env = cds.env.for('cds', process.cwd());

    const BindingManager = require('../lib/bind/bindingManager')
    const bindingManager = new BindingManager({ env })
    const bindingEnv = await bindingManager.bindingEnv()
    const processEnv = Object.assign(process.env, bindingEnv)

    execAndExit({ env: processEnv }, ...command);
}

function runCmd({ profile }, isJavaProject) {
    if (isJavaProject) {
        const p = profile === 'hybrid' ? '' : ` --profile ${profile}`;
        return `cds bind exec${p} mvn spring-boot:run`;
    } else {
        const p = profile === 'development' ? '' : ` --profile ${profile}`;
        return `cds watch${p}`;
    }
}

function setProfile(profile) {
    profile = parseProfile(profile);
    if (profile) process.env.CDS_ENV = profile;
}

function parseProfile(profile) {
    if (!profile) return 'hybrid';
    else if (profile === '-') return 'development';
    else return profile;
}
