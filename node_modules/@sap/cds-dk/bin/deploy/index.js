module.exports = Object.assign(deploy, {
  options: ['--to', '--tunnel-address', '--vcap-file'],
  flags: [ '--no-save', '--auto-undeploy', '--dry', '--xdry', '--with-mocks', '--store-credentials', '--bind' ],
  shortcuts: ['-2'],
  help: `
# SYNOPSIS

    *cds deploy* [ <model> ] [ <options> ]

    Deploys the given model to a database. If no model is given it looks up
    according configuration from _package.json_ or _.cdsrc.json_ in key
    _cds.requires.db_.  Same for the database.

    Supported databases: sqlite, hana


# OPTIONS

    *-2* | *--to* <database> [ : <database specific parameter> ],

      Where <database> is 'sqlite' or 'hana', <database specific parameter>
      can be a path to the database file (sqlite) or the service name (hana).

    *--dry*

      Just print the SQL statements without executing them.

    *--with-mocks*

      Also create tables for all entities from imported models.

    *--no-save*

      Do not modify the package.json file.

    *--auto-undeploy* (beta feature)

      Tell HDI deployer to automatically undeploy deleted resources.

    *--tunnel-address* (beta feature)

      Deploy through the given address (host:port) rather than the original
      database address.  The tunnel must have been opened before, e.g. using 'cf ssh'.

    *--vcap-file* (beta feature)

      Use credentials from the given file when deploying to *SAP HANA*, instead of
      creating new credentials. File must be in *default-env.json* format, with a root
      node *VCAP_SERVICES*. The following hdi related entries are supported:
      TARGET_CONTAINER, VCAP_SERVICES and SERVICE_REPLACEMENTS.

    *--store-credentials* (only in combination with *--to hana*)

      Stores credentials in *default-env.json file*. This is the former default behavior
      which has been replaced by creating and storing connection information in file
      *.cdsrc-private.json*.


# EXAMPLES
    cds deploy --to sqlite:db
    cds deploy --to hana
    cds deploy --to hana:myService --auto-undeploy

`})

const cds = require('../../lib/cds')

async function deploy (_model, options) { // NOSONAR

  if (options.bind) {
    console.log (`Option '--bind' is now active by default and can therefore be omitted.`)
  }

  if (_model && _model.length === 0)  _model = undefined // empty array (no model args) means default models
  const { 'to':url, 'no-save':no_save = cds.env.deploy.no_save } = options
  if (!options.mocked) { options.mocked  = options['with-mocks'] }
  if (!url && !cds.env.requires.db)  throw new Error(
    `Please specify a database kind or url, e.g.:

    cds deploy --to sql
    cds deploy --to sqlite
    cds deploy --to sqlite:db/my-db.sqlite
    `)

  const conf = cds.env.requires.db || {}
  const [,_kind,_db] = /(\w+)?(?::(.*))?/.exec(url||'')
  const kind = _kind || conf.dialect || conf.use || conf.kind

  try {
    var deployer = require ('./to-'+kind)
  } catch (e) {
    if (e.code === 'MODULE_NOT_FOUND') {
      throw new Error(`Didn't find a deployer module for '${kind}'`)
    }
  }
  try {
    await deployer.deploy (_model, _db, options)
    if (options.dry)  return
    if (kind === 'hana')  return // REVISIT: the hana deployer is a bit special
    if (url && !no_save)  await update_package_json (_kind, _model, _db)
  } catch (e) {
    if (e.code === 'MODEL_NOT_FOUND') {
      if (!_model) throw new Error ('No .cds models found, please specify one as an argument')
      throw new Error (`No cds models found at/in '${_model}'`)
    } else throw e
  }
}


async function update_package_json (kind, model, database) {
  const { fs, path, isfile } = cds.utils
  const { readFile, writeFile } = fs.promises
  const package_json = path.resolve (cds.root, 'package.json'), exists = isfile (package_json)
  const conf = exists ? JSON.parse (await readFile (package_json)) : {}
  conf.cds?.requires || (conf.cds = {requires: {}})
  const requires = conf.cds.requires
  const { schema_evolution } = requires.db ?? {}
  requires.db = cds.env.requires.db = { kind, model }
  if (database)  requires.db.credentials = { database }
  else if (kind === 'sqlite') requires.db.credentials = { database:'db.sqlite' }
  if (schema_evolution) requires.db.schema_evolution = schema_evolution
  await writeFile (package_json, JSON.stringify(conf,null,2))
  console.log (`/> ${ exists ? 'updated' : 'created' } .${path.sep}package_json`)
}

/* eslint no-console: off */
