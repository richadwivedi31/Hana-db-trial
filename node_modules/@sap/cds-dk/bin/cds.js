#!/usr/bin/env node


const cli = { //NOSONAR

  Shortcuts: {
    i: 'init',
    a: 'add',
    y: 'bind',
    m: 'import',
    c: 'compile',
    p: 'parse',
    s: 'serve',
    w: 'watch',
    e: 'env',
    b: 'build',
    d: 'deploy',
    l: 'login',
    o: 'logout',
    x: 'extend', '-a': 'activate',
    t: 'lint',
    v: 'version', '-v':'version', '--version':'version',
    h: 'help', '?':'help', '-?':'help', '--help':'help',
    r: 'repl', '-r':'repl',
    '-e':'eval'
  },

  exec (cmd = process.argv[2], ...argv) {
    if (!argv.length) argv = process.argv.slice(3)
    if (!cmd) cmd = process.stdin.isTTY ? 'help' : 'compile'
    if (cmd in this.Shortcuts) cmd = process.argv[2] = this.Shortcuts[cmd]
    if (argv.some(a => this.Shortcuts[a]==='help'))  return this.help (cmd)

    const cds_cli = require (_local('@sap/cds/bin/cds'))
    if (cmd !== 'repl' && process.env.NODE_ENV !== 'test')  cds_cli.errorHandlers()
    DEBUG && DEBUG (`[cds] - @sap/cds ${require('../lib/cds').version} loaded: ${require('../lib/cds').home}`)

    const task = this.load (cmd, /*else*/ (f)=> argv.unshift(cmd) && _defaultCompile (argv,f))
    if (task) {
      // REVISIT bind: '--' handling for cds bind --exec. Should be moved to cds_cli
      const endOfOptions = argv.indexOf('--')
      let appendArgs = []
      if (endOfOptions>=0) {
        appendArgs = argv.slice(endOfOptions+1)
        argv = argv.slice(0, endOfOptions)
      }
      const args = cds_cli.args(task,argv)
      args[0].push(...appendArgs)
      const resolveBindings = cmd in { run: 1, serve: 1, migrate: 1 } && argv.includes('--resolve-bindings')
      if (resolveBindings) return _resolveBindings().then(() => task.apply(this, args))
      else return task.apply(this, args)
    }
  },

  load (cmd,_default) {
    return /[^build/][\\/.-@]/.test(cmd) && _default && _default(true) // like `cds ./srv` or `cds @capire/bookshop`
    || /cds/i.test(cmd) && _dieForUnknownCommand (cmd)  // cds cds
    || _require ('./'+cmd)  // cds-dk commands
    || _require ('@sap/cds/bin/'+cmd, {paths:[process.cwd(), __dirname]}) // prefer local cds for the rest
    || _default && _default()
    || _dieForUnknownCommand (cmd)
  },

  help (cmd) { return this.exec ('help', cmd) }
}

const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) && console.debug

async function _resolveBindings() {
  const cds = require('../lib/cds')
  const BindingManager = require('../lib/bind/bindingManager')
  const bindingManager = new BindingManager()
  const bindingEnv = await bindingManager.bindingEnv()
  Object.assign(process.env, bindingEnv)
  cds.env = cds.env.for('cds') // reload env
}

function _local (id, _else) {
  try { return require.resolve (id, {paths:[process.cwd(), __dirname]}) }
  catch(e) {
    if (_else) return _else(e)
    else throw e
  }
}

function _defaultCompile (argv, _force) {
  // Try all arguments if one resolves to a model.  If yes, we assume 'compile' is intended.
  const model = _force || _is_model(argv)
  if (model)  return _require ('./compile')
  DEBUG && DEBUG (`[cds] - Command is not a model to compile: ${argv}`)
}

function _is_model (argv) {
  // IMPORTANT: have a separate env here, so that the normal one is not initialized before `cds_cli.args` above
  const env = require (_local('@sap/cds/lib/env/cds-env', ()=>_local('@sap/cds/lib/env'))).for('cds')
  const cds = require (_local('@sap/cds'))
  return !!cds.resolve(argv,{env,cache:{}})
}

function _dieForUnknownCommand(cmd) {
  const term = require('../lib/util/term');
  const fuzzySearch = _require('./util/fuzzySearch');

  let bestMatchText = '';

  const excludeList = ['cds.js', 'cds-ts.js', 'fix-redirects.js'];
  const { readdirSync } = require('fs');
  const { resolve } = require('path');
  const commands = readdirSync(__dirname, { withFileTypes: true })
    .concat(readdirSync(resolve(_local('@sap/cds'), '..', '..', 'bin'), { withFileTypes: true }))
    .filter((f) => f.isFile() && !excludeList.includes(f.name))
    .map((f) => f.name.split('.')[0]).sort();

  const bestMatches = fuzzySearch(cmd, commands, DEBUG);

  switch (bestMatches.length) {
    case 0:
      bestMatchText = '';
      break;
    case 1:
      bestMatchText = `A similar command is \n\n    ${term.bold("cds " + bestMatches[0])}`;
      break;
    default:
      bestMatchText = `Similar commands are \n\n    ${term.bold("cds " + bestMatches.join('\n    cds '))}`;
  }

  const msg = `
  Unknown command '${term.bold(cmd)}'. ${bestMatchText}

  Haven't found the proper command yet? Here are all supported commands:

    ${term.bold(commands.join('\n    '))}

  You can use ${term.bold("cds help [command]")} to get more information on the command.
`
  console.error(msg)

  process.exit(1)
}

function _require (id,o) {
  try { var resolved = require.resolve(id,o) } catch(e){ DEBUG && DEBUG (`[cds] - Command not found: ${id}`); return }
  DEBUG && DEBUG (`[cds] - Command resolved: ${resolved}`)
  return require (resolved)
}

module.exports = Object.assign ((..._) => cli.exec(..._), cli)

if (!module.parent)  module.exports()

/* eslint no-console:off */
