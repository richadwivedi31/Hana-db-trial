const path = require('path')
const mtxAdapter = require('./mtx-adapter')
const { createProject } = require('./extension-project')
const cds = require('@sap/cds')
const LOG = cds.log('mtx')
const { exists, fs: fsUtils  } = require('@sap/cds').utils
const fs = fsUtils.promises

module.exports._hasMtEnv = function _hasMtEnv() {
    return cds.requires.multitenancy || (cds.env.requires['cds.xt.DeploymentService'] && cds.env.requires['cds.xt.ModelProviderService'])
}

module.exports._hasExtensibiltyEnv = function _hasMtEnv() {
    return cds.requires.extensibility || cds.env.requires['cds.xt.ExtensibilityService']
}

module.exports._getExtensionProjectDirectory = async function(dir) {
    if (dir) {
        if (!exists(dir)) {
            // REVISIT do not allow relative path?
            await fs.mkdir(dir)
            LOG.log(`Project directory ${dir} does not exist. ${dir} has been created.`)
        }
        return dir
    } else {
        return await mtxAdapter.mkdirTemp()
    }
}

class MigrationResult {
    constructor() {
        this.connectedTenants = []
        this.results = {}
        this.hasError = false
    }

    addTenant(tenant, meta = true) {
        this.connectedTenants.push(tenant)
        if (meta) this.connectedTenants.push(mtxAdapter.getMetaTenantName(tenant))
    }

    log(tenant, message) {
        if (!this.results[tenant]) this.results[tenant] = []
        this.results[tenant].push(message)
        LOG.log(message)
    }

    error(tenant, message, error) {
        if (!this.results[tenant]) this.results[tenant] = []
        this.results[tenant].push(`${message} ${error.message}`)
        LOG.error(message, error)
        this.hasError = true
    }

    logResult(dry = false) {
        LOG.log(`Migration Result ${dry ? '(dry run only)' : ''}:`)
        for (const tenant of Object.keys(this.results)) {
            for (const line of this.results[tenant]) LOG.log(`[${tenant}] ${line}`)
        }
    }
}

module.exports.cleanupMetatenants = async function cleanup(tenants, options) {
    const migrationResult = new MigrationResult()
    const { force, dry } = options

    let tenantsToCleanup = tenants
    // handle tenant "*" -> retrieve all tenants
    if (tenants.includes('*')) {
        tenantsToCleanup = await mtxAdapter.getAllTenantIds()
    }

    const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
    migrationResult.addTenant(t0, false) // adds tenant for disconnect

    const metatenantsToCleanup = {}
    for (const tenant of tenantsToCleanup) {
        if (tenant === t0) continue
        const metatenant = mtxAdapter.getMetaTenantName(tenant)
        metatenantsToCleanup[tenant] = metatenant
    }

    // add common metatenant
    metatenantsToCleanup['__META__'] = '__META__'

    for (const [tenant, metatenant] of Object.entries(metatenantsToCleanup)) {
        migrationResult.addTenant(metatenant, false)

        try {
            // check if tenant was already migrated
            const migrated = tenant !== '__META__' ? await mtxAdapter.isMigrated(tenant) : { timestamp: true }
            if (!migrated.timestamp && !force) {
                migrationResult.log(tenant, `Tenant ${tenant} was not migrated. Skipping cleanup.`)
                continue
            }
            // do the cleanup
            if (!dry) {
                const ds = await cds.connect.to('cds.xt.DeploymentService')
                await ds.unsubscribe(metatenant)
            }
            migrationResult.log(metatenant, `Metatenant ${metatenant} successfully deleted.`)
        } catch (error) {
            migrationResult.error(metatenant, `Cleanup of tenant ${metatenant} failed.`, error)
        }
    }
    LOG.log('Cleanup done')
    return migrationResult
}

module.exports.migrate = async function migrate(tenants, options) {

    const { directory, dry, force, tagRule: tagRegex, tag: defaultTag } = options

    const migrationResult = new MigrationResult()
    let tenantsToMigrate = tenants

    // handle tenant "*" -> retrieve all tenants
    if (tenants.includes('*')) {
        tenantsToMigrate = await mtxAdapter.getAllTenantIds()
    }

    const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
    migrationResult.addTenant(t0, false) // adds tenant for disconnect

    const extensibility = module.exports._hasExtensibiltyEnv()
    let projectsDir

    for (const tenant of tenantsToMigrate) {

        migrationResult.addTenant(tenant)

        // skip migration of t0
        if (tenant === t0) {
            migrationResult.log(tenant, `Skipping internal tenant ${tenant}.`)
            continue
        }

        try {
            // check if tenant was already migrated
            const migrated = await mtxAdapter.isMigrated(tenant)
            if (migrated.timestamp && !force) {
                migrationResult.log(tenant, `Tenant ${tenant} is already migrated. Skipping migration.`)
                continue
            }

            // Get from old mtx
            const metadata = await mtxAdapter.getMetadata(tenant)

            if (extensibility) {

                // update tenant metadata + extension tables
                // add extension tables - TODO could also be done on-the-fly with push
                const extTables = await cds.load(`${__dirname}/../../db/extensions.cds`)
                cds.model = cds.db.model = cds.compile.for.nodejs(extTables)
                if (!dry) {
                    // disable extension deployment to avoid lengthy redeployments when doing the push()
                    const ds = await cds.connect.to('cds.xt.DeploymentService')
                    ds.prepend (srv => srv.on ('extend', (req) => { }))

                    try {
                        await cds.tx({ tenant}, tx => tx.run(SELECT.one(1).from('cds.xt.Extensions')))
                        //const one = await SELECT.one(1).from('cds.xt.Extensions')
                        // add metadata in case it had not been added before
                        await _addMetadata(tenant, metadata)
                    } catch (error) {
                        LOG.log('cds.xt.Extensions not yet deployed, deploying ...')
                        LOG.debug(error)
                        await ds.subscribe({ tenant, metadata, options: { csn: extTables } }) // also creates metadata ...
                    }
                }

                // run extend -> into memory?
                const mtxExtension = await mtxAdapter.getExtension(tenant)

                if (mtxExtension) {
                    // allow different folder from command line to preserve results
                    projectsDir = projectsDir || await module.exports._getExtensionProjectDirectory(directory)
                    const tenantProjectFolder = path.join(projectsDir, tenant)

                    await createProject(tenant, mtxExtension, projectsDir, tagRegex, defaultTag)

                    // upload and verify extensions
                    // iterate all tags
                    const tags = await fs.readdir(tenantProjectFolder)
                    migrationResult.log(tenant, `Created projects for tags "${tags}"`)

                    for (const tag of tags) {
                        const projectFolder = path.join(tenantProjectFolder, tag)
                        // Verify migrated extension
                        try {
                            await _verifyExtension(projectFolder, tenant)
                            migrationResult.log(tenant, `Extension verification successful for tenant ${tenant}`)
                        } catch (error) {
                            migrationResult.error(tenant, `Extension verification failed for tenant ${tenant}, skipping migration`, error)
                            continue
                        }

                        if (!dry) {
                            try {
                                const extensionTgz = await fs.readFile(path.join(projectFolder, 'gen', 'extension.tgz'))
                                const es = await cds.connect.to('cds.xt.ExtensibilityService')
                                await es.tx({ tenant, user: new cds.User.Privileged }, tx =>
                                    tx.push(extensionTgz.toString('base64'), tag)
                                )
                                migrationResult.log(tenant, `Extension for tenant ${tenant} and tag ${tag} pushed.`)
                            } catch (error) {
                                migrationResult.error(tenant, `Error pushing extension for tenant ${tenant} and tag ${tag}`, error)
                            }
                        }
                    }
                }
            } else {
                if (!dry) {
                    await _addMetadata(tenant, metadata)
                    migrationResult.log(tenant, `Metadata for tenant ${tenant} added.`)
                }
            }

            // TODO store status in __META__ tenant? Or use t0-tenant metadata (not save, can be in intermediate state)?
            if (!dry) await mtxAdapter.setMigrated(tenant)
            migrationResult.log(tenant, `Migration of tenant ${tenant} done.`)
        } catch (error) {
            migrationResult.error(tenant, `Migration of tenant ${tenant} failed.`, error)
        }
    }

    // cleanup tmpdir, keep directory if it was set externally
    if (!directory && projectsDir) await fs.rm(projectsDir, { recursive: true, force: true })

    // TODO check why process does not immediately terminate
    LOG.log('Extension migration done')
    return migrationResult
}

async function _addMetadata(tenant, metadata) {
    const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'
    // TODO Upsert ?
    try {
        await cds.tx({ tenant: t0 }, tx =>
          tx.run(INSERT.into('cds.xt.Tenants', { ID: tenant, metadata: JSON.stringify(metadata) }))
        )
    } catch (e) {
        if (e.message !== 'ENTITY_ALREADY_EXISTS') throw e
    }
}

async function _verifyExtension(projectFolder, tenant) {

    let extensionCsn
    try {
        const extensionCsnString = await fs.readFile(path.join(projectFolder, 'gen', 'ext', 'extension.csn'))
        extensionCsn = JSON.parse(extensionCsnString)
    } catch (error) {
        // if migration gets here there MUST be an extension -> throw error
        throw new Error(`No extension build result found for tenant ${tenant}`)
    }

    // check diff and abort if necessary
    // Toggles? -> all
    const mp = await cds.connect.to('cds.xt.ModelProviderService')
    const isExtended = await (async () => { try { return await mp.isExtended(tenant) } catch(error) { return false } })()
    const mainCsn = await mp.getCsn({ tenant, flavor: 'inferred', activated: true })
    const previewCsn = isExtended ? mainCsn : (extensionCsn ? cds.extend(mainCsn).with(extensionCsn) : mainCsn)
    const existingCsn = await mtxAdapter.getCsn(tenant)

    const existingHana = cds.compiler.to.hdi.migration(existingCsn)
    const newHana = cds.compiler.to.hdi.migration(previewCsn)

    // are artifacts lost?
    const hanaDiffNewToOld = cds.compiler.to.hdi.migration(cds.minify(previewCsn), {}, cds.minify(existingHana.afterImage))
    if (hanaDiffNewToOld.deletions.length) {
        throw new Error(`Verification error for tenant ${tenant}: migrated model is missing artifacts:\n ${hanaDiffNewToOld.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }

    // does the new model contain more artifacts?
    const MTXS_ENTITIES = ['cds.xt.Extensions']
    const hanaDiffOldToNew = cds.compiler.to.hdi.migration(cds.minify(existingCsn), {}, cds.minify(newHana.afterImage)) // cds.xt.Extensions is allowed
    const filteredDeletions = hanaDiffOldToNew.deletions.filter( ({name}) => !MTXS_ENTITIES.includes(name))
    if (filteredDeletions.length) {
        throw new Error(`Verification error for tenant ${tenant}: migrated model has additional artifacts:\n ${hanaDiffOldToNew.deletions.map( ({ name, suffix }) => `${name}${suffix}\n`)}`)
    }
}