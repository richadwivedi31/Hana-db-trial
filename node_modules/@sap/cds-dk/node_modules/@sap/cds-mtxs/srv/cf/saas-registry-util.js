const { URL } = require('url')
const axios = require('axios')
const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx')

module.exports = new class SaasRegistryUtil {

    async sendResult(callbackUrl, tenant, payload, authHeader) {
        const { status, message, subscriptionUrl, saasCallbackUrl, saasRequestPayload } = payload
        const data = { subscriptionUrl, message, status }

        // call to custom application callback -> piggyback original SaaS registry payload
        if (saasCallbackUrl) {
            Object.assign(data, { tenant, saasCallbackUrl, saasRequestPayload })
        }

        const headers = {}
        headers.authorization = authHeader ?? `Bearer ${await _saasRegistryToken()}`

        LOG.info('Sending result callback request to', callbackUrl)
        LOG.debug('Sending result with payload', data)

        // REVISIT: necessary?
        if (saasCallbackUrl) {
            Object.assign(headers, { status_callback: saasCallbackUrl })
        }

        try {
            return await axios(callbackUrl, { method: 'PUT', headers, data })
        } catch (error) {
            cds.error('Error sending result callback to saas-registry: ' + error.message) // REVISIT: Just throw error?
        }
    }

    parseHeaders(headers) {
        const { prefer, status_callback, mtx_status_callback } = headers ?? {}
        const { multitenancy, 'cds.xt.SaasProvisioningService': sps } = cds.env.requires
        const { saas_registry_url } = multitenancy?.credentials ?? sps?.credentials ?? {}
        const callbackUrl = mtx_status_callback ?? (status_callback && saas_registry_url && new URL(status_callback, saas_registry_url).toString())
        return {
            callbackUrl,
            isCustomCallback: !!mtx_status_callback,
            saasCallbackUrlPath: status_callback,
            isSync: !(prefer?.includes('respond-async') || callbackUrl)
        }
    }
}

async function _saasRegistryToken() {
    const { multitenancy, 'cds.xt.SaasProvisioningService': sps } = cds.env.requires
    const { clientid, clientsecret, url } = multitenancy?.credentials ?? sps?.credentials ?? {}
    if (!clientid || !clientsecret || !url) {
        cds.error('No saas-registry credentials available from the application environment.', { status: 401 })
    }

    try {
        LOG.info(`Getting saas-registry auth token from ${url}`)
        const { data: { access_token } } = await axios(`${url}/oauth/token`, {
            method: 'POST',
            auth: {
                username: clientid,
                password: clientsecret,
            },
            headers: {
                'Content-Type': 'application/json'
            },
            params: {
                grant_type: 'client_credentials',
                response_type: 'token'
            },
        })
        if (!access_token) {
            cds.error('Could not get saas-registry token: token is empty', { status: 401 })
        }
        return access_token
    } catch (error) {
        cds.error('Could not get auth token for saas-registry: ' + error.message, { status: 401 }) // REVISIT: Just throw error?
    }
}
