const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx')
const { parseHeaders, sendResult } = require('./saas-registry-util')
const DeploymentService = 'cds.xt.DeploymentService'
const JobsService = 'cds.xt.JobsService'
const Tenants = 'cds.xt.Tenants'

if (!cds.env.requires.multitenancy) cds.env.requires.multitenancy = true // we need to run in multitenancy mode for t0 ops
const { t0 = 't0' } = cds.env.requires.multitenancy

module.exports = class SaasProvisioningService extends cds.ApplicationService {

  async init() {
    this.on('UPDATE', 'tenant', this.create)
    this.on('READ', 'tenant', this.read)
    this.on('DELETE', 'tenant', this.delete)

    await super.init() // ensure to call super.init() // REVISIT: Why?
  }

  _options(data) {
    if (!data?.options && !data._ && !data._application_) return undefined
    const _ = data._application_?.sap ? { hdi: { create: data._application_.sap['service-manager'] } } : data._
    return { ...data.options, _ }
  }

  async _tenantsByDb(tenants) {
    let tenantToDbUrl
    if (cds.requires.db.kind === 'hana') {
      const hana = require('../plugins/hana/srv-mgr')
      tenantToDbUrl = (await hana.getAll(tenants)).reduce((res, t) =>
        ({ ...res, [t.labels.tenant_id[0]]: `${t.credentials.host}:${t.credentials.port}` })
      , {})
    } else {
      tenantToDbUrl = tenants.reduce((res, t) => ({ ...res, [t]: cds.db.getDbUrl(t) }), {})
    }
    const dbToTenants = {}
    for (const tenant of tenants) {
      const dbUrl = tenantToDbUrl[tenant]
      if (!dbToTenants[dbUrl]) dbToTenants[dbUrl] = new Set
      dbToTenants[dbUrl].add(tenant)
    }
    return Object.values(dbToTenants)
  }

  getAppUrl(subscriptionPayload, subscriptionHeaders) {
    return subscriptionHeaders?.application_url
        ?? process.env.SUBSCRIPTION_URL?.replace(`\${tenant_subdomain}`, subscriptionPayload.subscribedSubdomain)
        ?? 'Tenant successfully subscribed - no application URL provided'
  }

  _getSubscribedTenant(context) {
    const { data, params } = context ?? {}
    const { subscribedTenantId } = data ?? {}
    return params?.[0]?.subscribedTenantId ?? subscribedTenantId
  }

  async create(context) {
    LOG.debug('Received subscription request', context.data)
    const tenant = this._getSubscribedTenant(context)
    const { isSync } = parseHeaders(context.http?.req.headers)

    const sps = await cds.connect.to('cds.xt.SaasProvisioningService')
    const appUrl = await sps.getAppUrl(context.data, context.headers)
    if (isSync) {
      LOG.info(`Subscribing tenant ${tenant}`)
      try {
        const ds = await cds.connect.to(DeploymentService)
        const tx = ds.tx(context)
        await tx.subscribe(tenant, context.data, this._options(context.data))
        LOG.info(`Successfully subscribed tenant ${tenant}`)
        await this._sendCallback('SUCCEEDED', 'Tenant creation succeeded', appUrl)
      } catch (error) {
        await this._sendCallback('FAILED', 'Tenant creation failed')
        throw error
      }
      return appUrl
    }
    const js = await cds.connect.to(JobsService)
    const tx = js.tx(context)
    return tx.enqueue([new Set([tenant])], 'subscribe', [context.data, this._options(context.data)], error => {
      if (error) this._sendCallback('FAILED', 'Tenant creation failed')
      else this._sendCallback('SUCCEEDED', 'Tenant creation succeeded', appUrl)
    })
  }

  async read(context) { // TODO check params for get
    const tenant = this._getSubscribedTenant(context)
    if (tenant) {
      const one = await cds.tx({ tenant: t0 }, tx =>
        tx.run(SELECT.one.from(Tenants, { ID: tenant }, tenant => { tenant.metadata }))
      )
      if (!one) cds.error(`Tenant ${tenant} not found`, { status: 404 })
      return JSON.parse(one.metadata ?? '{}')
    }
    return (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID, tenant.metadata }))
    )).map(tenant => JSON.parse(tenant.metadata))
  }

  async upgrade(tenantsIds) {
    if (!tenantsIds?.length) return
    const tenantList = tenantsIds.includes('*') ? undefined : tenantsIds
    const tenants = tenantList ?? (await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID }))
    )).map(({ ID }) => ID)
    const { isSync } = parseHeaders(cds.context.http?.req.headers)
    const {
      clusterSize = 1, workerSize = 1, poolSize = 1
    } = cds.env.requires.multitenancy.jobs ?? cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}
    const dbToTenants = clusterSize > 1 ? await this._tenantsByDb(tenants) : [new Set(tenants)]
    LOG.info('Upgrading tenants', tenants)
    if (isSync) {
      try {
        const ds = await cds.connect.to(DeploymentService)
        const tx = await ds.tx(cds.context)
        await this.limiter(clusterSize, dbToTenants, tenants =>
          this.limiter(workerSize ?? poolSize, Array.from(tenants), t => tx.upgrade(t))
        )
        await this._sendCallback('SUCCEEDED', 'Tenant upgrade succeeded')
      } catch (error) {
        await this._sendCallback('FAILED', 'Tenant upgrade failed')
        throw error
      }
    } else {
      const js = await cds.connect.to(JobsService)
      const tx = js.tx(cds.context)
      // REVISIT: use jobs service for sync and async operations (might also be interesting for concurrency control)
      return tx.enqueue(dbToTenants, 'upgrade', [], error => {
        if (error) this._sendCallback('FAILED', 'Tenant upgrade failed')
        else this._sendCallback('SUCCEEDED', 'Tenant upgrade succeeded')
      })
    }
  }

  async delete(context) {
    LOG.debug('Received unsubscription request', context.data)
    const { isSync } = parseHeaders(context.http?.req.headers)

    const tenant = this._getSubscribedTenant(context)
    LOG.info(`Unsubscribing tenant ${tenant}`)

    const one = await cds.tx({ tenant: t0 }, tx =>
      tx.run(SELECT.one.from(Tenants, { ID: tenant }, t => { t.metadata }))
    ) ?? {}
    const metadata = JSON.parse(one?.metadata ?? '{}')

    if (isSync) {
      const ds = await cds.connect.to(DeploymentService)
      const tx = ds.tx(context)
      try {
        await tx.unsubscribe(tenant, { metadata })
        await this._sendCallback('SUCCEEDED', 'Tenant deletion succeeded')
      } catch (error) {
        if (error.statusCode === 404) {
          LOG.info(`Tenant ${tenant} is currently not subscribed`)
        } else {
          await this._sendCallback('FAILED', 'Tenant deletion failed')
          throw error
        }
      }
    } else {
      const lcs = await cds.connect.to(JobsService)
      const tx = lcs.tx(context)
      return tx.enqueue([new Set([tenant])], 'unsubscribe', [{ metadata }], error => {
        if (error) this._sendCallback('FAILED', 'Tenant deletion failed')
        else this._sendCallback('SUCCEEDED', 'Tenant deletion succeeded')
      })
    }
  }

  upgradeAll(tenants) {
    LOG.warn(`upgradeAll is deprecated. Use /-/cds/saas-provisioning/upgrade instead.`)
    return this.upgrade(tenants ?? ['*'])
  }

  dependencies() {
    return cds.env.requires['cds.xt.SaasProvisioningService']?.dependencies?.map(d => ({ xsappname: d })) ?? []
  }

  async limiter(limit, payloads, fn) {
    const pending = [], all = []
    for (const payload of payloads) {
      const execute = Promise.resolve().then(() => fn(payload))
      all.push(execute)
      const executeAndRemove = execute.then(() => pending.splice(pending.indexOf(executeAndRemove), 1))
      pending.push(executeAndRemove)
      if (pending.length >= limit) {
        await Promise.race(pending) // eslint-disable-line no-await-in-loop
      }
    }
    return Promise.allSettled(all)
  }

  async _sendCallback(status, message, subscriptionUrl) {
    const originalRequest = cds.context?.http?.req
    const { isSync, isCustomCallback, saasCallbackUrlPath, callbackUrl } = parseHeaders(originalRequest.headers)
    if (!isSync && callbackUrl) {
      /// TODO evaluate params for new rest adapter
      const tenant = this._getSubscribedTenant(originalRequest.body)
      const payload = { status, message, subscriptionUrl }

      // additional payload for internal callback (java)
      if (isCustomCallback) {
          Object.assign(payload, {
              saasRequestPayload: originalRequest.body,
              saasCallbackUrl: saasCallbackUrlPath
          })
      }
      LOG.debug(`Send callback to ${callbackUrl}`)
      try {
          await sendResult(callbackUrl, tenant, payload, isCustomCallback ? originalRequest.headers.authorization : undefined)
      } catch (error) {
          LOG.error(error)
      }
    }
  }
}
