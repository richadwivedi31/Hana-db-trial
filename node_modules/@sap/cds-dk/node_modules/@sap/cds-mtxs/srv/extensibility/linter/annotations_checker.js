const AT_REQUIRES = '@requires'
const AT_RESTRICT = '@restrict'
const AT_CDS_PERSISTENCE_JOURNAL = '@cds.persistence.journal'
const AT_SQL_APPEND = '@sql.append'
const AT_SQL_PREPEND = '@sql.prepend'
const AT_CODE_EXTEND = '@extension.code'

const checkedAnnotations = new Map([
  [AT_REQUIRES, _createSecurityAnnotationWarning],
  [AT_RESTRICT, _createSecurityAnnotationWarning],
  [AT_CDS_PERSISTENCE_JOURNAL, _createJournalAnnotationWarning],
  [AT_SQL_APPEND, _createSqlAnnotationWarning],
  [AT_SQL_PREPEND, _createSqlAnnotationWarning]
])

function _createSqlAnnotationWarning(annotationName, annoOrElem) {
  const message = `Annotation '${annotationName}' in '${
    annoOrElem.annotate || annoOrElem.name
  }' is not supported in extensions`
  return { message, element: annoOrElem }
}

function _createSecurityAnnotationWarning(annotationName, annoOrElem) {
  const message = `Security relevant annotation '${annotationName}' in '${
    annoOrElem.annotate || annoOrElem.name
  }' cannot be overwritten`
  return { message, element: annoOrElem }
}

function _createJournalAnnotationWarning(annotationName, annoOrElem) {
  const message = `Enabling schema evolution in extensions using '${annotationName}' in '${
    annoOrElem.annotate || annoOrElem.name
  }' not yet supported`
  return { message, element: annoOrElem }
}

function _createCodeAnnotationsWarning() {
  const message = `Code annotation '${AT_CODE_EXTEND}' in not allowed in model extension`
  return { message, element: null }
}

module.exports = class AnnotationsChecker {
  check(reflectedCsn, compileDir) {
    if (!reflectedCsn.extensions || !reflectedCsn.definitions) {
      return []
    }

    // annotations via annotate - applies for all
    const annotationExtensions = Object.values(reflectedCsn.extensions).filter(
      value => value.annotate && Object.getOwnPropertyNames(value).filter(property => checkedAnnotations.get(property))
    )

    // check annotations for extensions including fields
    reflectedCsn.forall(
      () => true,
      element => {
        if (element[AT_SQL_PREPEND] || element[AT_SQL_APPEND]) {
          if (!element.annotate) {
            // do not add annotation extensions again
            annotationExtensions.push(element)
          }
        }
      },
      reflectedCsn.extensions
    )

    // check entities and fields from definitions
    const annotatedDefinitions = []
    reflectedCsn.forall(
      () => true,
      element => {
        if (element[AT_SQL_PREPEND] || element[AT_SQL_APPEND] || element[AT_CDS_PERSISTENCE_JOURNAL]) {
          annotatedDefinitions.push(element)
        }
      },
      reflectedCsn.definitions
    )

    const warnings = []

    for (const annotationExtension of annotationExtensions) {
      const warning = this._checkAnnotation(annotationExtension, reflectedCsn.definitions, compileDir)
      if (warning) {
        warnings.push(warning)
      }
    }

    for (const annotatedDefinition of annotatedDefinitions) {
      const warning = this._checkAnnotation(annotatedDefinition, reflectedCsn.definitions, compileDir)
      if (warning) {
        warnings.push(warning)
      }
    }

    return warnings
  }

  _checkAnnotation(annotation, definitions, compileDir) {    
    if (annotation[AT_CODE_EXTEND]) {
      return _createCodeAnnotationsWarning()
    }

    if (!definitions[annotation.annotate]) {
      return this._createAnnotationsWarning(annotation, compileDir)
    }

    return null
  }

  _createAnnotationsWarning(annotation) {
    const annotationName = Object.getOwnPropertyNames(annotation).filter(property => checkedAnnotations.get(property))

    if (annotationName.length) {
      const fn = checkedAnnotations.get(annotationName[0]).bind(this)
      return fn(annotationName, annotation)
    }
  }
}
