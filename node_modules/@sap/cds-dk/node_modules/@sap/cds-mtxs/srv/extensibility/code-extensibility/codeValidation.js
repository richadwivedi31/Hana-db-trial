const parse_options = {
  ecmaVersion: 2020
}

const _getAsyncName = argument => {
  if (!argument) return
  if (argument?.callee?.object) {
    if (argument.callee.object.name) return argument.callee.object.name
    if (argument.callee.object.object?.name) return argument.callee.object.object.name
    return _getAsyncName(argument.callee.object)
  }
  if (argument?.tag?.object) {
    if (argument.tag.object.name) return argument.tag.object.name
    if (argument.tag.object.object?.name) return argument.tag.object.object.name
    return _getAsyncName(argument.tag.object)
  }
}             

const staticCheckCode = code => {  
    const acorn = require("acorn")
    const walk = require("acorn-walk")
    
    const findings = []
    const forbiddenConstructs = {
      ForStatement: 1,
      ForOfStatement: 1,
      WhileStatement: 1,
      NewExpression: 1,
      ThrowStatement: 1
    }
    const forbiddenNames = {
      Object: 1,
      Reflect: 1,
      global: 1,
      require: 1
    }
    const ast = acorn.parse(code, parse_options)
    walk.full(ast, node => { 
      if (node.type in forbiddenConstructs) {
        findings.push('Includes a forbidden construct: ' + node.type)
      }

      if (node.name in forbiddenNames) {
        findings.push('Includes a forbidden name: ' + node.name)
      }

      if (node.property?.name === 'prototype' || node.property?.name === '__proto__') {
        findings.push('Includes a forbidden construct: ' + node.property.name)
      }
      
      // a[b] or a['b'] or a[f(b)]
      if (node.type === 'MemberExpression' && node.computed && isNaN(node.property?.value)) {
        findings.push('Includes a forbidden member access using []')
      }

      if (node.type === 'AwaitExpression') {
        const name = _getAsyncName(node.argument)          
        if (!(name in {SELECT: 1, UPDATE: 1, CREATE: 1, DELETE: 1})) {
          findings.push('Await statement only allowed before SELECT/UPDATE/CREATE/DELETE: ' + 
            node.argument?.callee?.name || '' )
        }
      }
    })

    return findings
}

const generateCode = code => {
  const acorn = require("acorn")
  const escodegen = require('escodegen')

  const ast = acorn.parse(code, parse_options)
  return escodegen.generate(ast)
}

module.exports = { staticCheckCode, generateCode }
