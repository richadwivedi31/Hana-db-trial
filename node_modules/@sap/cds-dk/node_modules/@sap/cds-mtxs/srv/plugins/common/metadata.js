const cds = require('@sap/cds/lib')
const Tenants = 'cds.xt.Tenants'

exports.activated = 'Generic metadata'

// Add database-agnostic metadata handlers to DeploymentService...
cds.on ('served', () => {

  const { 'cds.xt.DeploymentService': ds } = cds.services
  const t0 = cds.env.requires.multitenancy?.t0 ?? 't0'

  ds.before ('*', req => {
    const { tenant } = req?.data ?? {}
    if (tenant) cds.context = { tenant }
  })

  ds.on ('subscribe', async (req, next) => {
    // REVISIT: Use UPSERT instead
    const { tenant, metadata } = req.data
    if (tenant === t0) return next()
    await next()
    try {
      await cds.tx({ tenant: t0 }, tx =>
        tx.run(INSERT.into(Tenants, { ID: tenant, metadata: JSON.stringify(metadata) }))
      )
    } catch (e) {
      if (e.message !== 'ENTITY_ALREADY_EXISTS') throw e
    }
  })
  ds.on ('unsubscribe', async (req, next) => {
    await next()
    await cds.tx({ tenant: t0 }, tx =>
      tx.run(DELETE.from(Tenants).where({ ID: req.data.tenant }))
    )
  })

  return async function _resubscribeT0IfNeeded() {
    await cds.connect() // REVISIT: Ideally shouldn't be necessary
    // REVISIT: schema evolution/delta deployment (might be unnecessarily expensive tho)
    // REVISIT: more elegant way to compare table names?
    //const tables = (await ds.getTables(t0)).map(t => t.toLowerCase()) // different casing for SQLite/HANA
    //const needsT0Redeployment =  ['cds_xt_tenants', 'cds_xt_jobs', 'cds_xt_tasks'].some(t => !tables.includes(t))
    await ds.tx({ tenant: t0 }, async tx => {
      const columns = await tx.getColumns(t0, cds.requires.db.kind === 'hana' ? 'CDS_XT_JOBS' : 'cds_xt_Jobs')
      const needsT0Redeployment = !columns.includes('error') && !columns.includes('ERROR')
      if (!needsT0Redeployment) return
      const csn = await cds.load(`${__dirname}/../../../db/t0.cds`)
      await tx.subscribe({ tenant: t0, options: { csn }})
    })
  }()
})
