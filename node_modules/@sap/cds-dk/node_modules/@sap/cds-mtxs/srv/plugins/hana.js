const cds = require('@sap/cds/lib'), {db} = cds.env.requires
const path = require('path')
module.exports = exports = { resources4, build, _imCreateParams, _disableAutoUndeploy }
const { cacheBindings = true, t0 = 't0' } = cds.requires.multitenancy ?? {}

// Check hana credentials to alert as early as possible
if (db?.kind === 'hana' && !db.credentials?.sm_url) {
  cds.error('No HANA credentials found. Make sure the application is bound to a BTP Service Manager instance.')
}
const useOldIm = cds.env.requires['cds.xt.DeploymentService']?.['old-instance-manager']
const hana = useOldIm ? require('./hana/inst-mgr') : require('./hana/srv-mgr')

if (db?.kind === 'hana') {

  exports.activated = 'HANA Database'

  // Add HANA-specific handlers to DeploymentService...
  cds.on ('served', () => {
    const { 'cds.xt.DeploymentService': ds } = cds.services

    ds.on ('subscribe', req => {
      const { tenant:t, options: { _: params, csn } = {}, metadata } = req.data
      // REVISIT: in which scenarios do we need to get the tenant _before_ the subscription (e.g. shared service manager/domain concept)

      // avoid undeploy if csn is passed - would potenially delete all tables
      const effectiveParams = csn ? _disableAutoUndeploy(params) : params

      return prepareAndDeploy (t, hana.acquire(t, _imCreateParams(t, effectiveParams, metadata)), effectiveParams, csn ?? csn4(), undefined, csn ? undefined : resources4(t))
    })
    ds.on ('upgrade', req => {
      const { tenant:t, options: { _: params } = {} } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t), undefined, resources4(t))
    })
    ds.on ('extend', req => {
      const { tenant:t, options: { _: params } = {}, csvs } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t), csvs, resources4(t)) // we don't support extensions with own resources yet
    })
    ds.on ('deploy', req => {
      const { tenant:t, options: { _: params, container, out } } = req.data
      return deploy (t, container, out, _hdiDeployParams(t, params))
    })
    ds.on ('unsubscribe', req => {
      const { tenant:t } = req.data
      if (cds.db) cds.db.disconnect(t) // Clean pool with active connections
      return hana.delete(t)
    })
    ds.on ('getTables', async req => {
      const { tenant:t } = req.data
      const { schema } = (t === t0 ? await hana.acquire(t, _imCreateParams(t)) : await hana.get(t)).credentials
      return (await cds.tx({ tenant: t }, tx =>
        tx.run('SELECT TABLE_NAME FROM TABLES WHERE SCHEMA_NAME = ?', [schema])
      )).map(({ TABLE_NAME }) => TABLE_NAME)
    })
    ds.on ('getColumns', async req => {
      const { tenant:t, table } = req.data
      const { schema } = (t === t0 ? await hana.acquire(t, _imCreateParams(t)) : await hana.get(t)).credentials
      return (await cds.tx({ tenant: t }, tx =>
        tx.run('SELECT * FROM TABLE_COLUMNS WHERE SCHEMA_NAME = ? AND TABLE_NAME = ?', [schema, table])
      )).map(({ COLUMN_NAME }) => COLUMN_NAME)
    })
  })

}

function _disableAutoUndeploy(params = {}) {
  return {
    hdi: {
      ...params.hdi,
      deploy: {
        ...params.hdi?.deploy,
        auto_undeploy: false
      }
    }
  }
}

function _imCreateParams(tenant, params = {}, metadata) {
  const createParamsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.create ?? {}
  const createParamsFromTenantOptions = cds.env.requires['cds.xt.DeploymentService']?.for?.[tenant]?.hdi?.create ?? {}
  const createParams = { ...createParamsFromEnv, ...createParamsFromTenantOptions, ...params?.hdi?.create }

  // @sap/instance-manager compat
  const compat = 'provisioning_parameters' in createParams || 'binding_parameters' in createParams
  if (compat) {
    createParams.provisioning_parameters = { ..._encryptionParams(metadata), ...createParams.provisioning_parameters }
    return createParams
  }

  // flatter @sap/cds-mtxs config
  const bindParamsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.bind ?? {}
  const bindParamsFromTenantOptions = cds.env.requires['cds.xt.DeploymentService']?.for?.[tenant]?.hdi?.bind ?? {}
  const bindParams = { ...bindParamsFromEnv, ...bindParamsFromTenantOptions, ...params?.hdi?.bind }
  return {
    provisioning_parameters: { ..._encryptionParams(metadata), ...createParams },
    binding_parameters: { ...bindParams }
  }
}

function _encryptionParams(data) {
  return data ? {
    subscriptionContext: {
      // crmId: '',
      globalAccountID: data.globalAccountGUID,
      subAccountID: data.subscribedSubaccountId,
      applicationName: data.subscriptionAppName
    }
  } : {}
}

function _hdiDeployParams(tenant, params = {}) {
  const paramsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.deploy || {}
  const paramsFromTenantOptions = cds.env.requires['cds.xt.DeploymentService']?.for?.[tenant]?.hdi?.deploy ?? {}
  return { ...paramsFromEnv, ...paramsFromTenantOptions, ...params?.hdi?.deploy }
}


const { fs, tar } = cds.utils
const LOG = cds.log('mtx')


async function csn4 (tenant) {
  const { 'cds.xt.ModelProviderService': mp } = cds.services
  return mp.getCsn ({ tenant, toggles: ['*'], activated: true }) // REVISIT: ['*'] should be the default?
}


async function resources4 (tenant) {

  const { 'cds.xt.ModelProviderService': mp } = cds.services
  const out = await fs.mkdirp ('gen',tenant)
  try {
    const rscs = await mp.getResources(true)
    await tar.xz(rscs).to(out)
    return out
  } catch (error) {
    // avoid that 404 bubbles up to response
    if (error.code) {
      error.code = 500
    }
    if (!error.message) {
      error.message = 'Could not get additional deployment resources'
    }
    throw error
  }
}

async function csvs4(tenant, csvs) {
  if (!csvs) return
  const out = await fs.mkdirp ('gen',tenant,'src','gen','data'), gen = []
  for (const [filename,csv] of Object.entries(csvs)) {
    // store files in src/gen/data
    const filepath = path.join(out, filename)
    gen.push (fs.promises.writeFile(filepath, csv))
  }
  return Promise.all (gen)
}


async function build (csn, tenant, csvs) {
  const out = await fs.mkdirp('gen', tenant, 'src', 'gen'), gen = []
  const options = { messages: [] }
  const { definitions: hanaArtifacts } = cds.compiler.to.hdi.migration(csn, options);
  const { getArtifactCdsPersistenceName } = cds.compiler

  const migrationTables = new Set(cds.reflect(csn)
    .all(item => item.kind === 'entity' && item['@cds.persistence.journal'])
    .map(entity => getArtifactCdsPersistenceName(entity.name, 'quoted', csn, 'hana'))
  )
  
  if (options.messages.length > 0) {
    // REVISIT: how to deal with compiler info and warning messages
    LOG._debug && LOG.debug('cds compilation messages:')
    LOG._debug && LOG.debug(options.messages)
  }

  for (const { name, suffix, sql } of hanaArtifacts) {
    if (suffix !== '.hdbtable' || !migrationTables.has(name)) {
      gen.push(fs.promises.writeFile(path.join(out, name + suffix), sql))
    }
  }

  // (re-) generate hdbtabledata files, only if new csvs have been added (extension)
  if (csvs) {
    const _tabledata4 = require('@sap/cds/bin/build/provider/hana/2tabledata')
    const tdata = await _tabledata4 (csn, { dirs: [path.join('gen',tenant,'src','gen','data')] })
    for (const [data, { file, csvFolder }] of tdata) {
      gen.push (fs.promises.writeFile(path.join(csvFolder,file), JSON.stringify(data)))
    }
  }

  return Promise.all (gen)
}


/** Arguments _hana, _csn and _resources are promises awaited inline below */
async function prepareAndDeploy (tenant, _hana, params, _csn, _extCsvs, ..._resources) {
  if (!cds.db) cds.db = cds.services.db = await cds.connect.to(db)

  const out = await fs.mkdirp ('gen',tenant)
  const [_container, _build] = await Promise.allSettled([
      _hana,
      (async () => {
        // Note: currently the hana files are created twice, first from getResources,
        // then from local compile -2 hana. This has to be adapted depending on if
        // the project is extended or not ideally the base hana files would have to
        // be filtered already when getting the resources

        // 1. unpack what comes from getResources()
        if (_resources) await Promise.all (_resources) //> has to finish before build

        // 1.5: csvs need to be resolved after all other resources have been resolved
        if (_extCsvs) await csvs4(tenant, _extCsvs)

        // 2. run cds compile -2 hana with potentially extended model from getCsn()
        const isExtensible = cds.requires.extensibility || cds.requires['cds.xt.ExtensibilityService']
        if (isExtensible || tenant === t0) {
          const csn = await _csn
          if (csn) await build (csn,tenant,_extCsvs)
        }

        if (tenant === t0) {
          await fs.write ({ "file_suffixes": {
            "csv":            { "plugin_name": "com.sap.hana.di.tabledata.source" },
            "hdbconstraint":  { "plugin_name": "com.sap.hana.di.constraint" },
            "hdbindex":       { "plugin_name": "com.sap.hana.di.index" },
            "hdbtable":       { "plugin_name": "com.sap.hana.di.table" },
            "hdbtabledata":   { "plugin_name": "com.sap.hana.di.tabledata" },
            "hdbview":        { "plugin_name": "com.sap.hana.di.view" }
          }}) .to (out,'src','gen','.hdiconfig')
        }
      })()
  ])
  try {
    if (_container.status === 'rejected') throw _container.reason
    if (_build.status === 'rejected') throw _build.reason

    // 3. hdi-deploy final build content
    const { 'cds.xt.DeploymentService': ds } = cds.services

    let container = _container.value
    if (cacheBindings) {
      // health-check credentials for DB connection, get uncached if stale
      const driver = require('@sap/cds/libx/_runtime/hana/driver')
      const client = require(driver.name).createClient(container.credentials)
      const { promisify } = require('util')
      const connect = promisify(client.connect.bind(client))
      const disconnect = promisify(client.disconnect.bind(client))
      try {
        await connect()
      } catch (e) {
        if (e?.message === 'authentication failed') container = await hana.get(tenant, { disableCache: true })
        else if (e) throw e
      } finally {
        await disconnect()
      }
    }
    return await ds.deploy({ tenant, options: { container, out, _: params } })
  } finally {
    await fs.rimraf (out) // REVISIT: keep that for caching later on
  }
}

async function deploy (tenant, container, out, options) {
  try {
    await hana.deploy (container, tenant, out, options)
    LOG.info(`Successfully finished HANA deployment for tenant ${tenant}`)
  } finally {
    await fs.rimraf (out)
  }
}
