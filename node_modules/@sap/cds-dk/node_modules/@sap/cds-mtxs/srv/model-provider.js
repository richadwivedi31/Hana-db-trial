const fs = require('fs').promises
const os = require('os')
const path = require('path')

const cds = require('@sap/cds/lib'), { tar, rimraf } = cds.utils
const conf = cds.requires['cds.xt.ModelProviderService'] || cds.requires.kinds['cds.xt.ModelProviderService']
const main = conf.root ? new class { //> we're running in sidecar -> use env of main app
  get env() { return super.env = cds.env.for ('cds', this.root) }
  get root() { return super.root = path.resolve (cds.root, conf.root) }
  get requires() { return super.requires = this.env.requires }
  cache = {} //> for cds.resolve()
} : { //> not in sidecar
  requires: cds.requires,
  root: cds.root,
  env: cds.env,
}
const fts = main.env.features.folders
const DEBUG = cds.debug('mtx')
if (DEBUG) cds.once('served', ()=> DEBUG ('model provider options:', conf))


module.exports = class ModelProviderService extends cds.ApplicationService {

  /**
   * Overload `.on` to decorate handlers to set `cds.context.tenant` based on incoming arg `tenant`.
   */
  on (event, handler) {
    return super.on(event, (req) => {
      if (req.data.tenant) cds.context = { tenant: req.data.tenant }
      // REVISIT: might not be correct when called via ExtensibilityService.add(...)
      //> const tenant = req.tenant || (req.user.is('internal-user') && req.data.tenant)
      return handler(req)
    })
  }

  init() {

    // REVISIT: We should do the enforcement only in production
    // let requires = this.definition['@requires_']
    // if (requires && process.env.NODE_ENV === 'production') this.before ('*', req => {
    //   if (!cds.context?.http) return //> not called from external
    //   if (req.user._is_anonymous) return req.reject({ code:401 })
    //   if (!requires.some(r => req.user.is(r))) return req.reject({ code:403 })
    // })

    this._in_sidecar = (conf.kind === 'in-sidecar') // REVISIT: eliminate this 'private API' if possible

    this.before(['getCsn', 'getEdmx', 'getExtCsn'], req => {
      const regex = /^[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)*$|^\$hash$|^\*$/
      const toggles = req.data?.toggles
      const invalid = Array.isArray(toggles) ? toggles.find(t => !regex.test(t)) :
                      typeof toggles === 'string' && !regex.test(toggles) && toggles
      if (invalid) return req.reject(400, `Unsupported input toggle param ${invalid}`)
    })

    this.on('getCsn', req => _getCsn(req))

    this.on('getExtCsn', req => {
      if (!main.requires.extensibility) return req.reject(400, 'Missing extensibility parameter')
      return _getCsn (req, true)
    })

    this.on('getEdmx', async req => {
      const { res } = req._; if (res) res.set('Content-Type', 'application/xml')
      const { service, model, locale, flavor } = req.data
      delete req.data.flavor // we need to delete the OData 'flavor' argument, as getCsn has a different CSN `flavor` argument
      const csn = model ? model : await _getCsn(req)
      const edmx = cds.compile.to.edmx(csn, { service, flavor })
      const extBundle = await _getExtI18n(req)

      return cds.localize(csn, locale, edmx, extBundle)
    })

    this.on('getResources', async req => {
      if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')
      // REVISIT: Works only w/o encoding parameter. Default encoding is 'utf8'.
      // try { return await cds.utils.read('resources.tgz') }
      // root is defined in cds.requires, in case of the sidecar scenario it is set to "_main"
      try { return await fs.readFile (path.resolve (main.root, 'resources.tgz')) }
      catch(e) { if (e.code !== 'ENOENT') throw e }
      const files = Object.keys(await cds.deploy.resources(['*', cds.env.features.folders]))
      if (!files.length) return req.reject(404)
      return tar.cz (files) // REVISIT: pipe to res instead of materializing buffer
    })

    this.on('isExtended', async req => {
      if (!main.requires.extensibility) return false
      if (!req.data.tenant && main.requires.multitenancy) return false
      const one = await SELECT.one(1).from('cds.xt.Extensions')
      return !!one
    })

    this.on('getExtensions', async req => {
      if (!main.requires.extensibility) return req.reject(400, 'Missing extensibility parameter')
      return await _getExtensions4(req.data.tenant) || req.reject(404, 'Missing extensions')
    })

    /** Implementation for getCsn */
    async function _getCsn (req, checkExt) {
      const { tenant, toggles, base, flavor, for:javaornode, activated } = req.data
      const extensions = !base && await _getExtensions4 (tenant, activated)
      if (!extensions && checkExt) req.reject(404, 'Missing extensions')

      const features = (!toggles || !main.requires.toggles) ? [] : toggles === '*' || toggles.includes('*') ? [fts] : toggles.map (f => fts.replace('*',f))
      const models = cds.resolve (['*',...features], main); if (!models) return

      DEBUG && DEBUG ('loading models for', { tenant, toggles } ,'from', models.map (cds.utils.local))
      let csn = await cds.load (models, { flavor, silent:true })
      if (csn.meta?.flavor === 'inferred') csn = cds.minify (csn)
      if (extensions) csn = cds.extend (csn) .with (extensions)
      if (javaornode) csn = cds.compile.for[javaornode] (csn)

      // Dirty hack for cds.localize in Node sidecar setup
      Object.defineProperty (csn,'$sources',{ value:csn.$sources, enumerable:true })
      return csn
    }

    /** Implementation for getExtensions */
    async function _getExtensions4 (tenant, activated = false) {
      if (!main.requires.extensibility || !tenant && main.requires.multitenancy) return
      try {
        const cqn = SELECT('csn').from('cds.xt.Extensions')
        if (activated) cqn.where('activated=', 'database')
        const exts = await cds.db.run(cqn)
        if (!exts.length) return

        const merged = { extensions: [], definitions: {} }
        for (let each of exts) {
          let {definitions,extensions} = JSON.parse(each.csn)
          if (definitions) Object.assign (merged.definitions, definitions)
          if (extensions) merged.extensions.push (...extensions)
        }
        return merged
      } catch (error) {
        DEBUG && DEBUG('cds.xt.Extensions not yet deployed', error)
        return
      }
    }

    async function _getExtI18n (req) {
      if (!main.requires.extensibility) return
      const { tenant, locale } = req.data
      if (!tenant && main.requires.multitenancy) return

      const cqn = SELECT('i18n').from('cds.xt.Extensions').where('i18n !=', null).orderBy('timestamp')
      const extBundles = await cds.db.run(cqn)

      let extBundle
      if (extBundles && extBundles.length) {
        extBundle = extBundles.reduce((acc, cur) => {
          const bundle = JSON.parse(cur.i18n)
          if (locale && bundle[locale]) acc[locale] = Object.assign(acc[locale] || {}, bundle[locale])
          acc[''] = Object.assign(acc[''] || {}, bundle['']) // default locale

          return acc
        }, {})
        extBundle = extBundle[locale] || extBundle['']
      }

      return extBundle
    }

  }
}
module.exports.prototype._add_stub_methods = true
