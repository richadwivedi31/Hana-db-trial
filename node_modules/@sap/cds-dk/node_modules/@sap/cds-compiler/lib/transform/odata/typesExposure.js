'use strict';

/**
 * In this module resides all the logic related to exposure of types as part of the OData backend
 * The exposure is run only for definitions which reside in a service.
 * @module typesExposure
 */

const { setProp } = require('../../base/model');
const { defNameWithoutServiceOrContextName, isArtifactInService } = require('./utils');
const { cloneCsnNonDict, isBuiltinType, forEachDefinition, forEachMember, forEachGeneric } = require('../../model/csnUtils');
const { copyAnnotations, getNamespace } = require('../../model/csnUtils');
const { isBetaEnabled } = require('../../base/model.js');
const { CompilerAssertion } = require('../../base/error');

function typesExposure(csn, whatsMyServiceName, requestedServiceNames, fallBackSchemaName, options, csnUtils, message) {
  const { error } = message;
  const special$self = !csn?.definitions?.$self && '$self';
  // are we working with OData proxies or cross-service refs
  const isMultiSchema = options.odataVersion === 'v4' && (options.odataProxies || options.odataXServiceRefs);
  // collect in this variable all the newly exposed types
  const schemas = Object.create(null);
  const exposedTypes = Object.create(null);
  // walk through the definitions of the given CSN and expose types where needed
  forEachDefinition(csn, (def, defName, propertyName, path) => {
    // we do expose types only for definition from inside services
    const serviceName = whatsMyServiceName(defName, false);
    // run type exposure only on requested services if not in multi schema mode
    // multi schema mode requires a proper type exposure for all services as a prerequisite
    // for the proxy exposure
    if (serviceName && requestedServiceNames.includes(serviceName)) {
      if (def.kind === 'type' || def.kind === 'entity') {
        forEachMember(def, (element, elementName, propertyName, path) => {
          if (propertyName === 'elements' || propertyName === 'params') {
            const newTypeName = getNewTypeName(element, elementName, defName, serviceName);
            exposeTypeOf(element, element.key || propertyName === 'params', elementName, defName, serviceName, newTypeName, path);
          }
        }, path);
      }

      // For exposed actions and functions that use non-exposed or anonymous structured types, create
      // artificial exposing types.
      // unbound actions
      if (def.kind === 'action' || def.kind === 'function') {
        exposeTypesOfAction(def, defName, defName, serviceName, path);
      }
      // bound actions
      def.actions && Object.entries(def.actions).forEach(([actionName, action]) => {
        exposeTypesOfAction(action, `${defName}_${actionName}`, defName, serviceName, path.concat(['actions', actionName]));
      });
    }
  });

  if(isBetaEnabled(options, 'odataTerms')) {
    forEachGeneric(csn, 'vocabularies', (def, defName, _propertyName, path) => {
    // we do expose types only for definition from inside services
      const serviceName = whatsMyServiceName(defName, false);
    // run type exposure only on requested services if not in multi schema mode
    // multi schema mode requires a proper type exposure for all services as a prerequisite
    // for the proxy exposure
      if (serviceName && requestedServiceNames.includes(serviceName)) {
        if(csn.definitions[defName]) {
        // error, duplicate definitions not allowed!
        // TODO: Use path as error location as soon as refs outside definitions are supported
          error('odata-definition-exists', ['vocabularies', defName], { anno: defName, '#':'anno' });
        }
        else {
        // link def into definitions for later use
          def.kind = 'annotation';
          csn.definitions[defName] = def;
          const artificialName = `term_${defName.replace(/\./g, '_')}`;//_${paramName}`;
          const newTypeName = getNewTypeName(undefined, undefined, artificialName, serviceName);
          exposeTypeOf(def, false, defName, defName, serviceName, newTypeName, path.concat(['vocabularies', defName]), undefined, true);
        }
      }
    });
  }

  return schemas;

/**
   * If an 'action' uses structured types as parameters or return values that are not exposed in 'service'
   * (because the types are anonymous or have a definition outside of 'service'),
   * create equivalent types in 'service' and make 'action' use them instead,
   * @param {Object} action
   * @param {String} actionName
   * @param {String} serviceName
   */
  function exposeTypesOfAction(action, actionName, defName, serviceName, path) {
    if (action.returns) {
      const artificialName = `return_${actionName.replace(/\./g, '_')}`;
      const newTypeName = getNewTypeName(action.returns, undefined, artificialName, serviceName);
      exposeTypeOf(action.returns, false, actionName, defName, serviceName, newTypeName, path.concat(['returns']));
    }

    action.params && Object.entries(action.params).forEach(([paramName, param]) => {
      const artificialName = `param_${actionName.replace(/\./g, '_')}`;//_${paramName}`;
      const newTypeName = getNewTypeName(param, paramName, artificialName, serviceName);
      exposeTypeOf(param, false, actionName, defName, serviceName, newTypeName, path.concat(['params', paramName]));
    });
  }

  /**
   * If 'node' exists and has a structured type that is not exposed in 'service', (because the type is anonymous or
   * has a definition outside of 'service'), create an equivalent type in 'service' and assign the new type
   * for a value of the 'node.type' property.
   * @param {Object} node
   * @param {String} memberName
   * @param {String} serviceName
   * @param {String} newTypeName
   */
  function exposeTypeOf(node, isKey, memberName, defName, serviceName, newTypeName, path, parentName, isTermDef=false) {
    const { isExposable, typeDef, typeName, elements, isAnonymous } = isTypeExposable();
    if (isExposable) {
      // this is the name used to register the new type in csn.definitions
      let fullQualifiedNewTypeName =
        isMultiSchema
          ? (node.type || (node.items?.type)
              ? getTypeNameInMultiSchema(node.type|| (node.items?.type), serviceName)
              : getAnonymousTypeNameInMultiSchema(newTypeName, parentName || defName))
          : `${serviceName}.${newTypeName}`;

      if (!isAnonymous) {
        // as soon as we leave of the anonymous world,
        // we're no longer in a key def => don't set notNull:true on named types
        if(isKey)
          isKey = false;
        // in case this was a named type and if the openess does not match the type definition
        // expose the type as a new one not changing the original definition.
        if(elements && (!!node['@open'] !== !!typeDef['@open']) && isBetaEnabled(options, 'odataOpenType'))
          fullQualifiedNewTypeName += node['@open'] ? '_open' : '_closed';
      }
      // check if that type is already defined
      let newType = csn.definitions[fullQualifiedNewTypeName];
      if (newType) {
        // error, if it was not exposed by us
        if (!exposedTypes[fullQualifiedNewTypeName]) {
          setProp(node, '$NameClashReported', true);
          error(null, path, { type: fullQualifiedNewTypeName, name: memberName },
            'Can\'t create artificial type $(TYPE) for $(NAME) because the name is already used');
          return { isExposable, typeDef, typeName, isAnonymous };
        }
      }
      else {
        /* Expose new structured type
         * Treat items.elements as ordinary elements for now.
         */
        if(elements) {
          newType = createNewStructType(elements);
          // if using node enforces open/closed, set it on type
          if(node['@open'] !== undefined)
            newType['@open'] = node['@open']
          if (node.$location)
            setProp(newType, '$location', node.$location);

          csn.definitions[fullQualifiedNewTypeName] = newType;
          exposedTypes[fullQualifiedNewTypeName] = 1;

          // Recurse into elements of 'type' (if any) and expose them as well (is needed)
          newType.elements && Object.entries(newType.elements).forEach(([elemName, newElem]) => {
            if (node.elements && node.elements[elemName].$location)
              setProp(newElem, '$location', node.elements[elemName].$location);
            defName = typeDef.kind === 'type' ? typeName : defName;
            {
              const { isExposable, typeDef, typeName } = exposeTypeOf(newElem, isKey, elemName, defName, serviceName,
                            getNewTypeName(newElem, elemName, newTypeName, serviceName), path, fullQualifiedNewTypeName, isTermDef);
              // if the type for the newElem was not exposed it may be a scalar type def from an external service that hasn't
              // been caught by expandToFinalBaseType() (forODataNew must not modify external imported services)
              if(!isExposable && isBuiltinType(typeName) && !isBuiltinType((newElem.items?.type || newElem.type))) {
                if(typeDef.items) {
                  newElem.items = typeDef.items;
                  delete newElem.type;
                }
                else if(newElem.items) {
                  newElem.items.type = typeName;
                  if(typeDef.enum)
                    newElem.items.enum = typeDef.enum;
                }
                else {
                  newElem.type = typeName;
                  if(typeDef.enum)
                    newElem.enum = typeDef.enum;
                }
              }
            }
          });
          copyAnnotations(typeDef, newType);
          // if the origin type had items, add items to exposed type
          if(typeDef.kind === 'type') {
            if(typeDef.items) {
              newType.items = { elements: newType.elements };
              delete newType.elements;
            }
          }
        }
        else if(isTermDef) {
          newType = Object.create(null);
          for(let n in typeDef) {
            newType[n] = typeDef[n];
          }
          newType.kind = 'type';
          csn.definitions[fullQualifiedNewTypeName] = newType;
          exposedTypes[fullQualifiedNewTypeName] = 1;
        }
      }
      // adjust current node to new type
      if(node.items) {
        delete node.items.elements;
        delete node.type;
        node.items.type = fullQualifiedNewTypeName;
      }
      else {
        delete node.elements;
        node.type = fullQualifiedNewTypeName;
      }
    }
    return { isExposable, typeDef, typeName, isAnonymous };

    /**
     * Check if the node's type can be exposed:
     * 1) If it's an anonymous, structured type (items.elements || elements)
     * 2) If it's a named type resolve to the final type definition and
     *    check if this is a structured type
     *
     * Returns an object that indicates
     *  - `isExposable`: whether the type needs exposure
     *  - `elements`: dictionary that needs to be cloned
     *  - `typeDef`: either the resolved type def or the node itself
     *  - `typeName`
     *  - if structured type was anonymously defined
     *
     * @returns {object} { isExposable, typeDef, typeName, elements, isAnonymous }
     */
    function isTypeExposable() {
      let typeName = undefined;
      let typeDef = node;
      let elements = (node.items?.elements || node.elements)
      // anonymous structured type
      if(elements)
        return { isExposable: true, typeDef, typeName, elements, isAnonymous: true };
      // named type, resolve the type to inspect it
      let type = node.items?.type || node.type;
      if(type) {
        typeName = (type.ref && csnUtils.artifactRef(type)) || type;
        const rc = { isExposable: true, typeDef, typeName, isAnonymous: false };
        if(!isBuiltinType(typeName) && typeName !== special$self) {
          rc.typeDef = typeDef = csnUtils.artifactRef(typeName, typeName);
          if(!isArtifactInService(typeName, serviceName)) {
            while(!isBuiltinType(typeName)) {
              typeDef = csnUtils.artifactRef(typeName, typeName);
              if(typeDef !== typeName) {
                // Implementation note: For `type S: T:struct;`, elements from `T:struct` were already propagated to `S`.
                if((isTermDef && typeDef.enum) || (rc.elements = (typeDef.items?.elements || typeDef.elements)) !== undefined)
                  return rc;
                type = typeDef.items?.type || typeDef.type;
                typeName = (type.ref && csnUtils.artifactRef(type)) || type;
              }
              else {
                throw new CompilerAssertion(`Please debug me: ${typeName} not found`);
              }
            }
          }
          else {
            rc.isExposable = false;
            return rc;
          }
        }
        // else if(isTermDef && typeDef.enum) {
        //   return rc;
        // }
      }
      return { isExposable: false, typeDef, typeName, isAnonymous: false };
    }


    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has a named type.
     *
     * @param {string} typeName type of the element
     * @param {string} serviceName current service name
     */
    function getTypeNameInMultiSchema(typeName, serviceName) {
      const typeService = whatsMyServiceName(typeName);
      if (typeService) {
        // new type name without any prefixes
        const typePlainName = defNameWithoutServiceOrContextName(typeName, typeService);
        const newSchemaName = `${serviceName}.${typeService}`;
        createSchema(newSchemaName);
        // return the new type name
        return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
      } else {
        const typeContext = csnUtils.getContextOfArtifact(typeName);
        const typeNamespace = getNamespace(csn, typeName);
        const newSchemaName = `${serviceName}.${typeContext || typeNamespace || fallBackSchemaName}`;
        // new type name without any prefixes
        const typePlainName = typeContext
          ? defNameWithoutServiceOrContextName(typeName, typeContext)
          : (typeNamespace
              ? typeName.replace(typeNamespace + '.', '')
              : typeName);
        createSchema(newSchemaName);
        // return the new type name
        return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
      }
    }

    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has an anonymous type.
     *
     * @param {string} typeName type of the element
     * @param {string} parentName name of the parent def holding the element
     */
    function getAnonymousTypeNameInMultiSchema(typeName, parentName) {
      let currPrefix = parentName.substring(0, parentName.lastIndexOf('.'));
      const newSchemaName = currPrefix || fallBackSchemaName;
      // new type name without any prefixes
      const typePlainName = defNameWithoutServiceOrContextName(typeName, newSchemaName);

      createSchema(newSchemaName);
      return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
    }

    /**
     * Tf does not exists, create a context with the given name in the CSN
     * @param {string} name
     */
    function createSchema(name) {
      schemas[name] = { kind: 'schema', name };
    }

    /**
     * create a new structured type for 'elements'
     * @param {Object} elements
     */
    function createNewStructType(elements) {
      // Create a type with empty elements
      const type = {
        kind: 'type',
        elements: Object.create(null),
      };
      setProp(type, '$exposedBy', 'typeExposure');

      // Duplicate elements
      Object.entries(elements).forEach(([elemName, element]) => {
        let cloned = cloneCsnNonDict(element, options);
        // if this was an anonymous sub element of a key, mark it as not nullable
        if(isAnonymous && isKey && !cloned.key && cloned.notNull === undefined)
          cloned.notNull = true;
        type.elements[elemName] = cloned;
      });
      return type;
    }
  }

  /*
   * Calculate the name of the exposed type based on the information, the element can provide
   * If the element is typed, use the type name
   * else assume it's a de-anonymized type, concatenate the element name to the defName
  */
  function getNewTypeName(element, elementName, typeNamePrefix, serviceName) {
    // for the new type name node.type has precedence over node.items.type
    const typeName = (!element?.elements && element?.type || !element?.items?.elements && element?.items?.type);
    return typeName
        ? `${isMultiSchema
              ? typeName.split('.').pop() // use leaf element
              : typeName.replace(/\./g, '_')}` // concatenate path
        : ( elementName // returns has no elementName, return the precalculated prefix
            ? `${defNameWithoutServiceOrContextName(typeNamePrefix, serviceName).replace(/\./g, '_')}_${elementName}`
            : typeNamePrefix
          );
  }
}

module.exports = typesExposure;
