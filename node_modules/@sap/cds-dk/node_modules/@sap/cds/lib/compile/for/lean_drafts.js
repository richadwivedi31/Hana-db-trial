const cds = require ('../../index')
module.exports = function cds_compile_for_lean_drafts(csn, o) {
  const DRAFT_ELEMENTS = new Set([
    'IsActiveEntity',
    'HasDraftEntity',
    'HasActiveEntity',
    'DraftAdministrativeData',
    'DraftAdministrativeData_DraftUUID',
    'SiblingEntity'
  ])
  function _redirect(assoc, target, keys) {
    assoc.target = target.name
    assoc._target = target
    if (keys) assoc.on = _onCondition(assoc.name, keys)
  }

  function _onCondition(left, keys, right) {
    const on = []
    for (let k in keys)
      DRAFT_ELEMENTS.has(k) || on.push({ ref: [left, k] }, '=', { ref: right ? [right, k] : [k] }, 'and')
    on.pop()
    return on
  }

  const { Draft } = cds.linked(`
  entity ActiveEntity { key ID: UUID; }
  entity Draft {
    virtual IsActiveEntity            : Boolean; // REVISIT: these are calculated fields, aren't they?
    virtual HasDraftEntity            : Boolean; // REVISIT: these are calculated fields, aren't they?
    HasActiveEntity                   : Boolean; // This should be written !!!
    DraftAdministrativeData           : Association to DRAFT.DraftAdministrativeData;
    DraftAdministrativeData_DraftUUID : UUID;
    // SiblingEntity                  : Association to ActiveEntity; // REVISIT: Why didn't we use a managed assoc here?
  }
  entity DRAFT.DraftAdministrativeData {
    key DraftUUID         : UUID;
    LastChangedByUser     : String(256);  LastChangeDateTime : Timestamp;
    CreatedByUser         : String(256);  CreationDateTime   : Timestamp;
    InProcessByUser       : String(256);
    DraftIsCreatedByMe    : Boolean; // REVISIT: these are calculated fields, aren't they?
    DraftIsProcessedByMe  : Boolean; // REVISIT: these are calculated fields, aren't they?
  }
`).definitions
  function draftEntity(active, model) {
    const _draftEntity = active.name + '.drafts'
    const d = model.definitions[_draftEntity]
    if (d) return d
    // We need to construct a fake draft entity definition
    const draft = { __proto__: active, name: _draftEntity, elements: { ...active.elements, ...Draft.elements } }
    Object.defineProperty(model.definitions, _draftEntity, { value: draft })
    Object.defineProperty(active, 'drafts', { value: draft })
    draft['@cds.persistence.table'] = _draftEntity
    // Recursively add drafts for compositions
    for (const each in draft.elements) {
      const e = draft.elements[each]
      const newEl = Object.create(e)
      if (e.isComposition || (e.isAssociation && e['@odata.draft.enclosed']) || e._isCompositionBacklink) {
        _redirect(newEl, draftEntity(e._target, model))
      }
      newEl.parent = draft
      draft.elements[each] = newEl
    }
    // TODO: Redirect associations to localized
    return draft
  }
  for (const name in csn.definitions) {
    const def = csn.definitions[name]
    if (!def._isDraftEnabled || def.name.endsWith('.DraftAdministrativeData'))
      continue
      // so that database ignores them
    ;[
      'IsActiveEntity',
      'HasDraftEntity',
      'HasActiveEntity',
      'DraftAdministrativeData_DraftUUID',
      'DraftAdministrativeData'
    ].forEach(s => {
      def.elements[s].virtual = true
    })
    // will insert drafts entities, so that others can use `.drafts` even without incoming draft requests
    draftEntity(def, csn, Draft)
  }
}
