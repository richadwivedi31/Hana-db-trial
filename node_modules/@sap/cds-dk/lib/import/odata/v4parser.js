/* eslint-disable no-prototype-builtins */
/**
 * OData V4 to CSN parser
 */

"use strict";
let messages = require("../message").getMessages();
let common = require("../common");
let versionInfo = require("../../../package.json").version;
let Multimap = require("./util/MultiMap");
const ignoreObjects = ["$Reference"]; // add all the objects that needs to be ignored for parsing.
const validEdmDatatypes = ["Edm.DateTimeOffset"];
const { warn } = require("../../util/term");
const MetadataConverterFactory = require("./metadataconverter/MetadataConverterFactory");
const cds = require('../../cds');

const edmxncdsdatatype = {
    "Edm.String": "cds.LargeString",
    "Edm.Boolean": "cds.Boolean",
    "Edm.Int16": "cds.Integer",
    "Edm.Int32": "cds.Integer",
    "Edm.Int64": "cds.Integer64",
    "Edm.Decimal": "cds.Decimal",
    "Edm.DateTimeOffset": "cds.DateTime",
    "Edm.TimeOfDay": "cds.Time",
    "Edm.Date": "cds.Date",
    "Edm.Binary": "cds.LargeBinary",
    "Edm.Guid": "cds.UUID",
    "Edm.Double": "cds.Double",
    // Special handling of data types
    "Edm.String_m": "cds.String", // Max length
    "Edm.Decimal_p": "cds.Decimal", // Precision, scale
    //'Edm.DateTime_f': 'cds.Date', // sap:display-format="Date"
    //'Edm.DateTimeOffset_f': 'cds.Date', // sap:display-format="Date"
    "Edm.Binary_m": "cds.Binary", // Max Length
    "Edm.Byte_m": "cds.Integer", // Max Length
    "Edm.Double_p": "cds.Double", // Precision, scale
    // Special handling with annotations
    "Edm.Byte_a": "cds.Integer",
    "Edm.SByte_a": "cds.Integer",
    "Edm.Single_a": "cds.Double",
    "Edm.Stream_a": "cds.LargeBinary",
    "Edm.DateTimeOffset_a": "cds.Timestamp",
};

const known_vocabularies = {
    'Org.OData.Authorization.V1': 'Authorization',
    'Org.OData.Aggregation.V1': 'Aggregation',
    'Org.OData.Core.V1': 'Core',
    'Org.OData.Capabilities.V1': 'Capabilities',
    'Org.OData.Validation.V1': 'Validation',
    'Org.OData.Measures.V1': 'Measures',
    'Org.OData.Repeatability.V1': 'Repeatability',

    'com.sap.vocabularies.Analytics.v1': 'Analytics',
    'com.sap.vocabularies.CodeList.v1': 'CodeList',
    'com.sap.vocabularies.Common.v1': 'Common',
    'com.sap.vocabularies.Communication.v1': 'Communication',
    'com.sap.vocabularies.Graph.v1': 'Graph',
    'com.sap.vocabularies.HTML5.v1': 'HTML5',
    'com.sap.vocabularies.ODM.v1': 'ODM',
    'com.sap.vocabularies.PersonalData.v1': 'PersonalData',
    'com.sap.vocabularies.Session.v1': 'Session',
    'com.sap.vocabularies.UI.v1': 'UI',
};

function _initialize(parserContext) {
    parserContext.unboundedActions = {};
    parserContext.boundedActions = {};
    parserContext.unboundedFunctions = {};
    parserContext.boundedFunctions = {};
    parserContext.entityTypes = [];
    parserContext.entityTypeOpenEntries = [];
    parserContext.complexTypeOpenEntries = [];
    parserContext.namespace = "";
    parserContext.complexTypes = {};
    parserContext.enumTypes = {};
    parserContext.typeDefinitions = {};
    parserContext.jsonEntityContainerName = "";
    parserContext.entitySetToEntityTypeMap = new Multimap();
    parserContext.actionImportToActionMap = new Multimap();
    parserContext.functionImportToFunctionMap = new Multimap();
}

function _isJson(edmx) {
    let isJson = false;
    try {
        JSON.parse(edmx);
        isJson = true;
    } catch (err) {
        isJson = false;
    }
    return isJson;
}

function _isValidDataType(propertyType) {
    if (validEdmDatatypes.includes(propertyType)) {
        return true;
    }
    return false;
}

function _isValidJSON(jsonObj, parserContext) {
    if (jsonObj.$Version && _hasEntityContainer(jsonObj, parserContext) && jsonObj[parserContext.namespace]) {
        return true;
    }
    else {
        throw new Error(messages.INVALID_EDMX_METADATA);
    }
}

function _hasEntityContainer(jsonObj, parserContext) {
    let jsonObjEntityContainer = jsonObj.$EntityContainer;
    try {
        if (jsonObjEntityContainer) {
            // scenario: Schema Namespace="A.B.C.D" & jsonObjEntityContainer is "A.B.C.D.EntityContainerName"
            let lastIndex = jsonObjEntityContainer.lastIndexOf('.');
            parserContext.namespace = jsonObjEntityContainer.substring(0, lastIndex);
            parserContext.jsonEntityContainerName = jsonObjEntityContainer.substring(lastIndex + 1);
        }
        if (jsonObj[parserContext.namespace][parserContext.jsonEntityContainerName] &&
            jsonObj[parserContext.namespace][parserContext.jsonEntityContainerName] instanceof Object
        ) {
            return true;
        } 
    } catch (err) {
        throw new Error(messages.MISSING_ENTITY_CONTAINER);
    }
}

function _includeExternalNamespaceAnnotation(source, target) {
    Object.entries(source).forEach(element => {
        if (element[0].startsWith('@')) {
            target[element[0]] = element[1];
        }
    });
}

function _addNotNull(property, isCollection) {
    if (isCollection) property.items["notNull"] = true;
    else property["notNull"] = true; 
}

function _typeWithCollections(property, type, isCollection) {
    if (isCollection === true) {
        let typeKeys = Object.keys(type);
        for (let i = 0; i < typeKeys.length; i++) {
            if (typeKeys[i].startsWith("@")) {
                property[typeKeys[i]] = type[typeKeys[i]];
                delete type[typeKeys[i]];
            }
        }
        property.items = type;
    } else {
        Object.assign(property, type);
    }
}

function generatePropertyCsn(propertyType, isPrimaryKey) {
    let property = {};
    let typeProperties = {};
    if (isPrimaryKey) {
        property.key = true;
        // primary key cannot be of type Collection
        if (propertyType.$Collection)
            throw new Error(messages.COLLECTION_IN_KEY);
        if (propertyType.$Nullable === true) {
            console.log(warn("Expected key element to be not nullable"));
        }
        typeProperties["notNull"] = true;
    }
    else {
        if ((propertyType.$Nullable !== true) && (propertyType.$Kind !== 'TypeDefinition')) {
            typeProperties["notNull"] = true;
        }
    }
    _includeExternalNamespaceAnnotation(propertyType, property);
    // conditions have to be made
    if (propertyType.$MaxLength) {
        if (propertyType.$Type) {
            if (propertyType.$Type == "Edm.Binary" && propertyType.$MaxLength >= 5000) {
                console.log(warn("MaxLength for type Edm.Binary should not exceed 5000"));
            }
            typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_m'];
        } else {
            typeProperties.type = 'cds.String'; // if type is missing, then it is String type
        }
        typeProperties.length = propertyType.$MaxLength;
    } else if (_isValidDataType(propertyType.$Type)) {
        if (propertyType.$Precision && propertyType.$Precision > 0) {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_a'];
            typeProperties["@odata.Precision"] = propertyType.$Precision;
        } else {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type];
            // typeProperties["@odata.Precision"] = 0;
        }
    } else if (propertyType.$Precision && !_isValidDataType(propertyType.$Type)) {
        typeProperties.type = edmxncdsdatatype[propertyType.$Type + '_p'];
        if (propertyType.$Scale && !(propertyType.$Scale == 'variable' || propertyType.$Scale == 'floating')) {
            typeProperties.scale = propertyType.$Scale;
            typeProperties.precision = propertyType.$Precision;
        }
    } else if (edmxncdsdatatype[propertyType.$Type + "_a"]) {
        typeProperties.type = edmxncdsdatatype[propertyType.$Type + "_a"];
    } else if (propertyType.$Type) {
        if (edmxncdsdatatype[propertyType.$Type]) {
            typeProperties.type = edmxncdsdatatype[propertyType.$Type];
        }
        else {
            typeProperties.type = propertyType.$Type;
        }
    } else {
        typeProperties.type = 'cds.LargeString'; // if type is missing, then it is String type
    }

    if (edmxncdsdatatype[propertyType.$Type + '_a']) {
        if (edmxncdsdatatype[propertyType.$Type + '_a'] === 'cds.LargeBinary') {
            typeProperties["@Core.MediaType"] = 'application/octet-stream';
        }
        else {
            typeProperties["@odata.Type"] = propertyType.$Type;
        }
    }

    _typeWithCollections(property, typeProperties, propertyType.$Collection);

    return property;
}

function _generateComplexTypePropertyCsn(propertyType) {
    let property = {};
    let type = { type: propertyType.$Type }
    _typeWithCollections(property, type, propertyType.$Collection);
    if (!propertyType.$Nullable) _addNotNull(property, propertyType.$Collection);

    return property;
}

function _generateTypeDefinitionPropertyCsn(propertyType) {
    let property = {};
    let type = { type: propertyType.$Type };

    _includeExternalNamespaceAnnotation(propertyType, property);
    _typeWithCollections(property, type, propertyType.$Collection);
    if (!propertyType.$Nullable) _addNotNull(property, propertyType.$Collection);

    return property;
}

function _parseAssociationProperty(foreignReference, associationNode, mockServerUc, parserContext) {
    let associationProperty = {};
    let foreignKeys;
    // var foreignReference = associationNode.$Type;
    let refConstraint = associationNode.$ReferentialConstraint;
    let i;
    let data;
    let ref;
    associationProperty.type = (associationNode.$OnDelete === 'Cascade') ? 'cds.Composition' : 'cds.Association';
    // annotation for ON condition
    associationProperty["@cds.ambiguous"] = 'missing on condition?';
    // associationProperty.target = associationNode.$Type;

    //Code for NavigationProperty for notNull
    /*if(associationProperty.$Nullable != true){
        associationProperty["notNull"] = true;
    }*/
    if (mockServerUc && parserContext.entitySetToEntityTypeMap && parserContext.entitySetToEntityTypeMap.get(associationNode.$Type)) {
        if (parserContext.entitySetToEntityTypeMap.get(associationNode.$Type).length > 1) {
            for (let j = 0; j < parserContext.entitySetToEntityTypeMap.get(associationNode.$Type).length; j++) {
                if (parserContext.entitySetToEntityTypeMap.get(associationNode.$Type)[j] === foreignReference) {
                    associationProperty.target = parserContext.namespace + '.' +
                        parserContext.entitySetToEntityTypeMap.get(associationNode.$Type)[j];
                }
            }
        } else {
            associationProperty.target = parserContext.namespace + '.' + parserContext.entitySetToEntityTypeMap.get(associationNode.$Type);
        }
    } else {
        associationProperty.target = associationNode.$Type;
    }
    // cardinality
    associationProperty.cardinality = {};
    if (associationNode.$Collection) {
        associationProperty.cardinality.max = '*';
    } else {
        associationProperty.cardinality.max = 1;
    }
    // on -> "SalesOrders.CustomerID=CustomerID and SalesOrders.Type=Type"
    if (refConstraint) {
        associationProperty.on = [];
        foreignKeys = Object.keys(refConstraint);
        for (i = 0; i < foreignKeys.length; i++) {
            data = {};
            ref = [];
            ref.push(foreignReference);
            ref.push(refConstraint[foreignKeys[i]]);
            data.ref = ref;
            associationProperty.on.push(data);
            associationProperty.on.push('=');
            data = {};
            ref = [];
            ref.push(foreignKeys[i]);
            data.ref = ref;
            associationProperty.on.push(data);
            if (i < foreignKeys.length - 1) {
                associationProperty.on.push(' and ');
            }
        }
    }
    // Convert managed associations and compositions in unmanaged with empty key to avoid
    // "generation" of keys, that do not exist in the external service.
    if (common.checkForEmptyKeys(associationProperty, "V4")) {
        associationProperty.keys = [];
    }
    _includeExternalNamespaceAnnotation(associationNode, associationProperty);
    return associationProperty;
}

function _getBaseTypeEntityName(baseType, parserContext) {
    const mappedResult = parserContext.entitySetToEntityTypeMap.get(baseType);
    // if one entity type has mapping to multiple entity sets, use the first entity set
    if (mappedResult.length > 1) {
        return parserContext.namespace + '.' + mappedResult[0];
    } else {
        return parserContext.namespace + '.' + mappedResult;
    }
}

function _addBlobElement() {
    return {
        "blob": {
            "@Core.MediaType": 'application/octet-stream',
            "type": "cds.LargeBinary"
        }
    }
}

function _generateCSNForEntityType(ignorePersistenceSkip, mockServerUc, parserContext) {
    let entityCsn = {};
    let keySet;
    let curKey;
    let j;
    let propertyType;
    let enumType = {};
    parserContext.entityTypes.forEach(element => {
        let key = Object.keys(element)[0];
        let baseType = element[key].$BaseType;
        let isAbstract = element[key].$Abstract;
        let isOpenType = element[key].$OpenType;
        if (key) {
            entityCsn[key] = {};
            entityCsn[key].kind = 'entity';
            entityCsn[key]['@cds.external'] = true;
            if (!ignorePersistenceSkip) {
                entityCsn[key]['@cds.persistence.skip'] = true;
            }
            if (element[key].$Singleton) {
                entityCsn[key]['@odata.singleton'] = true;
            }
            if (element[key].$SingletonNullable) {
                entityCsn[key]['@odata.singleton.nullable'] = true;
            }
            _includeExternalNamespaceAnnotation(element[key], entityCsn[key]);
            // inheritance
            if (baseType) {
                entityCsn[key].includes = [];
                // if the baseType has a mapping to an entity set use that
                if (parserContext.entitySetToEntityTypeMap && parserContext.entitySetToEntityTypeMap.get(baseType)) {
                    baseType = _getBaseTypeEntityName(baseType, parserContext);
                }
                entityCsn[key].includes.push(baseType);
                if (!parserContext.entityTypeOpenEntries.includes(baseType)) parserContext.entityTypeOpenEntries.push(baseType);
            }
            if ((isAbstract || isOpenType) && !parserContext.entityTypeOpenEntries.includes(key)) {
                parserContext.entityTypeOpenEntries.push(key);
            }
            entityCsn[key].elements = {};
            keySet = [];
            Object.keys(element[key]).forEach(property => {
                // Annotations names can have either @ or .; Don't add in generated CSN as property.
                // CDS compiler will throw error when property name has special characters
                if ((property.indexOf('@') == -1) && (property.indexOf('.') == -1)) {
                    if (element[key][property] instanceof Object) {
                        if (property === '$Key') {
                            curKey = element[key].$Key;
                            for (j = 0; j < curKey.length; j++) {
                                keySet.push(curKey[j]);
                            }
                        } else if (!element[key][property].$Type || edmxncdsdatatype[element[key][property].$Type] ||
                            edmxncdsdatatype[element[key][property].$Type + "_a"]
                        ) {
                            propertyType = element[key][property];
                            if (keySet.includes(property)) {
                                entityCsn[key].elements[property] = generatePropertyCsn(propertyType, true);
                            } else {
                                entityCsn[key].elements[property] = generatePropertyCsn(propertyType, false);
                            }
                        } else if (!element[key][property].$Type || parserContext.enumTypes[element[key][property].$Type]) {
                            enumType = element[key][property];
                            if (keySet.includes(property)) {
                                entityCsn[key].elements[property] = generatePropertyCsn(enumType, true);
                            } else {
                                entityCsn[key].elements[property] = generatePropertyCsn(enumType, false);
                            }
                        } else if (parserContext.complexTypes[element[key][property].$Type]) {
                            propertyType = element[key][property];
                            entityCsn[key].elements[property] = _generateComplexTypePropertyCsn(propertyType);
                        } else if (element[key][property].$Kind === 'NavigationProperty') {
                            entityCsn[key].elements[property] = _parseAssociationProperty(property, element[key][property], mockServerUc, parserContext);
                        } else if (parserContext.typeDefinitions[element[key][property].$Type]) {
                            // for TypeDefinitions
                            propertyType = element[key][property];
                            entityCsn[key].elements[property] = _generateTypeDefinitionPropertyCsn(propertyType);
                        } else {
                            let message = '"' + element[key][property].$Type + '" is not supported (in element:"' + property + '")';
                            console.log(warn(message));
                        }
                    }
                }
            });
            if (element[key].$HasStream) {
                entityCsn[key].elements = { ...entityCsn[key].elements, ..._addBlobElement() }
            }
        }
    });

    // add @open annotations
    parserContext.entityTypeOpenEntries.forEach(key => {
        if (entityCsn[key]) entityCsn[key]['@open'] = true;
    });

    return entityCsn;
}

function _generateEntityType(schemaData, mockServerUc, parserContext) {
    let entity = {};
    let temp;
    Object.keys(schemaData).forEach(entityType => {
        entity = {};
        if (schemaData[entityType] instanceof Object) {
            if (schemaData[entityType].$Kind && schemaData[entityType].$Kind === 'EntityType') {
                if (mockServerUc) {
                    let entityTypeName = parserContext.namespace + '.' + entityType;
                    if (parserContext.entitySetToEntityTypeMap && parserContext.entitySetToEntityTypeMap.get(entityTypeName)) {
                        if (parserContext.entitySetToEntityTypeMap.get(entityTypeName).length > 1) {
                            let entity1 = {};
                            for (let i = 0; i < parserContext.entitySetToEntityTypeMap.get(entityTypeName).length; i++) {
                                entity1 = {};
                                let entityDetails = {};
                                let temp1 = parserContext.namespace + '.' + parserContext.entitySetToEntityTypeMap.get(entityTypeName)[i];
                                entity1[temp1] = Object.assign({}, schemaData[entityType]);
                                entityDetails = schemaData[parserContext.jsonEntityContainerName][parserContext.entitySetToEntityTypeMap.get(entityTypeName)[i]];
                                if (entityDetails.$Singleton)
                                    entity1[temp1].$Singleton = entityDetails.$Singleton;
                                if (entityDetails.$SingletonNullable)
                                    entity1[temp1].$SingletonNullable = entityDetails.$SingletonNullable;
                                parserContext.entityTypes.push(entity1);
                            }
                        } else {
                            temp = parserContext.namespace + '.' + parserContext.entitySetToEntityTypeMap.get(entityTypeName);
                            entity[temp] = schemaData[entityType];
                            let entityDetails = schemaData[parserContext.jsonEntityContainerName][parserContext.entitySetToEntityTypeMap.get(entityTypeName)];
                            if (entityDetails.$Singleton)
                                entity[temp].$Singleton = entityDetails.$Singleton;
                            if (entityDetails.$SingletonNullable)
                                entity[temp].$SingletonNullable = entityDetails.$SingletonNullable;
                            parserContext.entityTypes.push(entity);
                        }
                    } else {
                        temp = parserContext.namespace + '.' + entityType;
                        entity[temp] = schemaData[entityType];
                        parserContext.entityTypes.push(entity);
                    }
                } else {
                    temp = parserContext.namespace + '.' + entityType;
                    entity[temp] = schemaData[entityType];
                    parserContext.entityTypes.push(entity);
                }
            }
        }
    });
}

function _parseEntityType(schemaDataList, ignorePersistenceSkip, mockServerUc, parserContext) {
    // collect entity types
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        _generateEntityType(schemaData, mockServerUc, parserContext);
    }
    return _generateCSNForEntityType(ignorePersistenceSkip, mockServerUc, parserContext);
}

function _parseEntityContainer(entityCSN, schemaData, parserContext) {
    Object.entries(schemaData[0][parserContext.jsonEntityContainerName]).forEach(entry => {
        if (entityCSN[parserContext.namespace + '.' + entry[0]])
            // Captured the annotations at entity set and entity type name level
            _includeExternalNamespaceAnnotation(entry[1], entityCSN[parserContext.namespace + '.' + entry[0]]);
        if (entry[0].startsWith('@')) {
            // Captured the annotations at entity container name level
            entityCSN[parserContext.namespace][entry[0]] = entry[1];
        }
    });
    return entityCSN;
}

function _generateEnumType(schemaData, parserContext) {
    let enumTypeDict = {};
    let temp;
    Object.keys(schemaData).forEach(curEnumType => {
        if (schemaData[curEnumType] instanceof Object) {
            if (schemaData[curEnumType].$Kind && schemaData[curEnumType].$Kind === 'EnumType') {
                temp = parserContext.namespace + '.' + curEnumType;
                enumTypeDict[temp] = schemaData[curEnumType];
            }
        }
    });
    return enumTypeDict;
}

function _collectEnumType(schemaDataList, parserContext) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        parserContext.enumTypes = _generateEnumType(schemaData, parserContext);
    }
    return parserContext.enumTypes;
}

function _generateCSNForEnumType(schemaData, parserContext) {
    let enumCsn = {};
    let eTypes;
    eTypes = _collectEnumType(schemaData, parserContext);
    Object.keys(eTypes).forEach(element => {
        enumCsn[element] = {};
        enumCsn[element].kind = 'type';
        enumCsn[element]['@cds.external'] = true;
        enumCsn[element].enum = {};
        enumCsn[element].type = eTypes[element].$Type != null ? edmxncdsdatatype[eTypes[element].$Type] : 'cds.LargeString';
        Object.keys(eTypes[element]).forEach(property => {
            if (property != "$Kind" && property != "$Type") {
                if (enumCsn[element].type == 'cds.LargeString') {
                    enumCsn[element].enum[property] = cds.parse.expr(`'${(eTypes[element][property])}'`);
                }
                else {
                    enumCsn[element].enum[property] = cds.parse.expr(`${(eTypes[element][property])}`);
                }
            }
        });
    });
    return enumCsn;
}

function _generateTypeDefinition(schemaData, parserContext) {
    let typeDefDict = {};
    let temp;
    Object.keys(schemaData).forEach(curTypeDef => {
        if (schemaData[curTypeDef] instanceof Object) {
            if (schemaData[curTypeDef].$Kind && schemaData[curTypeDef].$Kind === 'TypeDefinition') {
                temp = parserContext.namespace + '.' + curTypeDef;
                typeDefDict[temp] = schemaData[curTypeDef];
            }
        }
    });
    return typeDefDict;
}

function _collectTypeDefinition(schemaDataList, parserContext) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        parserContext.typeDefinitions = _generateTypeDefinition(schemaData, parserContext);
    }
}

function _generateBounded(schemaData, flag, parserContext) {
    let bFunction = {};
    let boundedFunction = [];
    let temp;
    let kindString;
    if (flag == 1) {
        kindString = 'Function';
    }
    else {
        kindString = 'Action';
    }
    Object.keys(schemaData).forEach(curFunction => {
        if (schemaData[curFunction] instanceof Array &&
            schemaData[curFunction][0].$Kind === kindString &&
            schemaData[curFunction][0].$IsBound === true
        ) {
            boundedFunction = [];
            temp = parserContext.namespace + '.' + curFunction;
            for (let i = 0; i < schemaData[curFunction].length; i++) {
                boundedFunction.push(schemaData[curFunction][i]);
                bFunction[temp] = boundedFunction;
            }
        }
    });
    return bFunction;
}

function _captureOptionalParameter(annotation, path) {
    let param = annotation[0].split('/');
    let defaultvalue = annotation[1]["@Core.OptionalParameter"]["DefaultValue"];
    if (path.params === undefined) {
        _addDefaultValueObject(path, defaultvalue);
    }
    else {
        _addDefaultValueObject(path.params[param[1]], defaultvalue);
    }
    return path;
}

function _addDefaultValueObject(path, defaultvalue) {
    // for collection, default value isin't expected
    if (path.items === undefined) {
        path.default = {};
        path.default.val = (defaultvalue) ? defaultvalue : null;
    }
}

function _collectBounded(schemaDataList, flag, parserContext) {
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        if (flag == 0) {
            parserContext.boundedActions = _generateBounded(schemaData, 0, parserContext);
        }
        else {
            parserContext.boundedFunctions = _generateBounded(schemaData, 1, parserContext);
        }
    }
}

function _getDatatype(datatype, parserContext) {
    let type = undefined;
    if (datatype === undefined) {
        type = "cds.LargeString"; // intentionally used LargeString
    } else if (parserContext.entitySetToEntityTypeMap.get(datatype) && parserContext.entitySetToEntityTypeMap.get(datatype)[0]) {
        // mapping to entity set if type is entity type
        type = parserContext.namespace + "." + parserContext.entitySetToEntityTypeMap.get(datatype)[0];
    } else if (parserContext.complexTypes[datatype] || parserContext.typeDefinitions[datatype] || parserContext.enumTypes[datatype]) {
        // if type is complex type, type definition or an enum type
        type = datatype;
    } else {
        // checking if type is an entity set
        for (const element of parserContext.entitySetToEntityTypeMap.keys()) {
            if (parserContext.namespace + "." + parserContext.entitySetToEntityTypeMap.get(element) === datatype)
                type = datatype;
        }
        parserContext.entityTypes.forEach(entity => {
            if (entity[datatype])
                type = datatype;
        })
    }

    // will return undefined if type is not supported
    return type;
}

function _parseBounded(csnDefs, flag, parserContext) {
    let boundedEdmxKind, boundedObj, boundedCsnKind, boundedEntityName, obj, paramName, paramObj, name;
    if (flag == 0) {
        boundedEdmxKind = "Action";
        boundedCsnKind = "action";
        boundedObj = parserContext.boundedActions;
    }
    else {
        boundedEdmxKind = "Function";
        boundedCsnKind = "function";
        boundedObj = parserContext.boundedFunctions;
    }
    if (Object.keys(boundedObj).length > 0) {
        Object.keys(boundedObj).forEach(b => {
            for (let j = 0; j < boundedObj[b].length; j++) {
                if (boundedObj[b][j].$Kind === boundedEdmxKind) {
                    name = b.substring(b.lastIndexOf(".") + 1);
                    obj = boundedObj[b];
                    boundedEntityName = obj[j].$Parameter[0].$Type;
                    if (csnDefs[boundedEntityName] === undefined) {
                        boundedEntityName = parserContext.namespace + "." + parserContext.entitySetToEntityTypeMap.get(boundedEntityName)[0];
                    }
                    if (csnDefs[boundedEntityName]) {
                        if (csnDefs[boundedEntityName].actions === undefined)
                            csnDefs[boundedEntityName].actions = {};
                        csnDefs[boundedEntityName].actions[name] = {};
                        _includeExternalNamespaceAnnotation(obj[0], csnDefs[boundedEntityName].actions[name]);
                        csnDefs[boundedEntityName].actions[name].kind = boundedCsnKind;
                        // add params
                        if (obj[j].$Parameter && obj[j].$Parameter.length >= 2) {
                            /** 
                             * 1. Considering length >= 2 because we need to consider from the 2nd
                             *    parameter onwards. 1st parameter only tells which entity is this
                             *    action/function bounded to and that parameter is no where used 
                             *    to retrieve any data during service runtime. So skipping it and
                             *    the details of 1st parameter will not be preserved in the csn.
                             * 2. The 1st parameter will be reflected back as parameter name  "in" 
                             *    during csn to edmx conversion by the compiler.
                             * */
                            csnDefs[boundedEntityName].actions[name].params = {};
                            for (let i = 1; i < obj[j].$Parameter.length; i++) {
                                paramObj = obj[j].$Parameter[i];
                                paramName = obj[j].$Parameter[i].$Name;
                                let paramType = {};
                                let annotations = {};
                                _includeExternalNamespaceAnnotation(paramObj, annotations);
                                // check if the parameter type is pre-defined, undefined or custom defined
                                if (edmxncdsdatatype[paramObj.$Type] || edmxncdsdatatype[paramObj.$Type + "_a"])
                                    paramType = generatePropertyCsn(paramObj, false);
                                else {
                                    let type = _getDatatype(paramObj.$Type, parserContext);
                                    if (type) paramType["type"] = type;
                                }
                                if (Object.keys(paramType).length > 0) {
                                    if (paramType.type || paramType.items.type) {
                                        // check if parameter type is a collection
                                        if (paramObj.$Collection && !paramType.items) {
                                            csnDefs[boundedEntityName].actions[name].params[paramName] = {};
                                            csnDefs[boundedEntityName].actions[name].params[paramName].items = paramType;
                                            if(paramObj.$Nullable != true){
                                                csnDefs[boundedEntityName].actions[name].params[paramName].items["notNull"] = true;
                                            }
                                        } else {
                                            csnDefs[boundedEntityName].actions[name].params[paramName] = paramType;
                                            if (!paramType.items) {
                                                if(paramObj.$Nullable != true){
                                                    csnDefs[boundedEntityName].actions[name].params[paramName].notNull = true;
                                                }
                                            }
                                    }
                                }
                                else {
                                    let message = '"' + paramObj.$Type + '" is not supported (in element:"' + name + '")';
                                    console.log(warn(message));
                                }
                                if (csnDefs[boundedEntityName].actions[name].params[paramName])
                                    Object.assign(csnDefs[boundedEntityName].actions[name].params[paramName], annotations);
                            }
                        }
                    }
                    // if parameters has no entries
                    if (csnDefs[boundedEntityName].actions[name].params && Object.keys(csnDefs[boundedEntityName].actions[name].params).length === 0) {
                        delete csnDefs[boundedEntityName].actions[name].params;
                    }
                    // add returns
                    if (obj[j].$ReturnType) {
                        let returnType = {};
                        let annotations = {};
                        // check if the return type is pre-defined, undefined or custom defined
                        if (edmxncdsdatatype[obj[j].$ReturnType.$Type] || edmxncdsdatatype[obj[j].$ReturnType.$Type + "_a"])
                            returnType = generatePropertyCsn(obj[j].$ReturnType, false);
                        else {
                            let type = _getDatatype(obj[j].$ReturnType.$Type, parserContext);
                            _includeExternalNamespaceAnnotation(obj[j].$ReturnType, annotations);
                            if (type) returnType["type"] = type;
                        }
                        if (Object.keys(returnType).length > 0) {
                            if (returnType.type || returnType.items.type) {
                                csnDefs[boundedEntityName].actions[name].returns = {};
                                // check if return type is a collection
                                if (obj[j].$ReturnType.$Collection && !returnType.items) {
                                    csnDefs[boundedEntityName].actions[name].returns.items = returnType;
                                    if(obj[j].$ReturnType.$Nullable != true){
                                        csnDefs[boundedEntityName].actions[name].returns.items["notNull"] = true;
                                    }
                                }
                                else {
                                    csnDefs[boundedEntityName].actions[name].returns = returnType;
                                    if (!returnType.items) {
                                        if(obj[j].$ReturnType.$Nullable != true){
                                            csnDefs[boundedEntityName].actions[name].returns["notNull"] = true;
                                        }
                                    }
                                }
                            }
                        } else {
                            let message = '"' + obj[j].$ReturnType.$Type + '" is not supported (in return type)';
                            console.log(warn(message));
                        }
                        if (csnDefs[boundedEntityName].actions[name].returns)
                            Object.assign(csnDefs[boundedEntityName].actions[name].returns, annotations)
                    }
                }
            }
        }
        });
    }
}

function _generateComplexType(schemaData, parserContext) {
    let complexTypeDict = {};
    let temp;
    Object.keys(schemaData).forEach(curComplexType => {
        if (schemaData[curComplexType] instanceof Object) {
            if (schemaData[curComplexType].$Kind && schemaData[curComplexType].$Kind === 'ComplexType') {
                temp = parserContext.namespace + '.' + curComplexType;
                complexTypeDict[temp] = schemaData[curComplexType];
            }
        }
    });
    return complexTypeDict;
}

function _collectComplexType(schemaDataList, parserContext) {
    // collect complex types
    let schemaData;
    for (let i = 0; i < schemaDataList.length; i++) {
        schemaData = schemaDataList[i];
        parserContext.complexTypes = _generateComplexType(schemaData, parserContext);
    }
    return parserContext.complexTypes;
}

function _generateCSNForComplexType(schemaData, parserContext) {
    let complexCsn = {};
    let cTypes;
    let propertyType;
    let baseType, isAbstract, isOpenType;
    let enumType;
    cTypes = _collectComplexType(schemaData, parserContext);
    Object.keys(cTypes).forEach(element => {
        complexCsn[element] = {};
        complexCsn[element].kind = 'type';
        complexCsn[element]['@cds.external'] = true;
        complexCsn[element].elements = {};
        // inheritance handling
        baseType = cTypes[element].$BaseType;
        isAbstract = cTypes[element].$Abstract;
        isOpenType = cTypes[element].$OpenType;
        if (baseType) {
            complexCsn[element].includes = [];
            complexCsn[element].includes.push(baseType);
            if (!parserContext.complexTypeOpenEntries.includes(baseType)) parserContext.complexTypeOpenEntries.push(baseType);
        }
        if ((isAbstract || isOpenType) && !parserContext.complexTypeOpenEntries.includes(element)) {
            parserContext.complexTypeOpenEntries.push(element);
        }        
        Object.keys(cTypes[element]).forEach(property => { // cTypes[element][property].$Type.startsWith('Edm.')
            if (cTypes[element][property] instanceof Object) {
                if (!cTypes[element][property].$Type ||
                    edmxncdsdatatype[cTypes[element][property].$Type] ||
                    edmxncdsdatatype[cTypes[element][property].$Type + "_a"]
                ) {
                    propertyType = cTypes[element][property];
                    complexCsn[element].elements[property] = generatePropertyCsn(propertyType, false);
                } else if (parserContext.complexTypes[cTypes[element][property].$Type]) {
                    propertyType = cTypes[element][property];
                    complexCsn[element].elements[property] = _generateComplexTypePropertyCsn(propertyType);
                } else if (parserContext.typeDefinitions[cTypes[element][property].$Type]) {
                    propertyType = cTypes[element][property];
                    complexCsn[element].elements[property] = _generateTypeDefinitionPropertyCsn(propertyType);
                } else if (parserContext.enumTypes[cTypes[element][property].$Type]) {
                    enumType = cTypes[element][property];
                    complexCsn[element].elements[property] = generatePropertyCsn(enumType, false);
                } else {
                    let message = '"' + cTypes[element][property].$Type + '" is not supported (in element:"' + property + '")';
                    console.log(warn(message));
                }
            } else if (property.startsWith("@")) {
                complexCsn[element][property] = cTypes[element][property];
            }
        });
    });

    // add @open annotations
    parserContext.complexTypeOpenEntries.forEach(key => {
        if (complexCsn[key]) complexCsn[key]['@open'] = true;
    });

    return complexCsn;
}

function _parseTypeDefinition(parserContext) {
    let typeDef = {};
    let propertyType;
    Object.keys(parserContext.typeDefinitions).forEach(element => {
        typeDef[element] = {};
        typeDef[element].kind = 'type';
        typeDef[element]['@cds.external'] = true;
        if (!parserContext.typeDefinitions[element].$Type ||
            edmxncdsdatatype[parserContext.typeDefinitions[element].$Type]
        ) {
            propertyType = parserContext.typeDefinitions[element];
            typeDef[element] = Object.assign(typeDef[element], generatePropertyCsn(propertyType, false));
        }
    });
    return typeDef;
}

function _parseUnbounded(schemaData, flag, parserContext) {
    let unboundedObj = {}, unbounded, unboundedCsnKind;
    let importToMap = new Multimap();
    if (flag == 0) {
        unbounded = parserContext.unboundedActions;
        importToMap = parserContext.actionImportToActionMap;
        unboundedCsnKind = "action";
    }
    else {
        unbounded = parserContext.unboundedFunctions;
        importToMap = parserContext.functionImportToFunctionMap;
        unboundedCsnKind = "function";
    }
    if (Object.keys(unbounded).length > 0) {
        Object.keys(unbounded).forEach(ub => {
            let obj = {};
            let objType = {}, objData = {}, temp = {};
            if (importToMap && importToMap.get(ub)) {
                temp = ub.split(".").pop();
                objType = parserContext.namespace + "." + temp;
                objData = schemaData[0][temp][0];
                obj[objType] = {};
                obj[objType].kind = unboundedCsnKind;
                obj[objType]['@cds.external'] = true;
                _includeExternalNamespaceAnnotation(objData, obj[objType]);
                // add params
                if (objData.$Parameter && objData.$Parameter.length > 0) {
                    obj[objType].params = {};
                    for (let i = 0; i < objData.$Parameter.length; i++) {
                        let paramType = {};
                        let annotations = {};
                        _includeExternalNamespaceAnnotation(objData.$Parameter[i], annotations);
                        // check if the parameter type is pre-defined, undefined or custom defined
                        if (edmxncdsdatatype[objData.$Parameter[i].$Type] || edmxncdsdatatype[objData.$Parameter[i].$Type + "_a"]) {
                            paramType = generatePropertyCsn(objData.$Parameter[i], false)
                        } else {
                            let type = _getDatatype(objData.$Parameter[i].$Type, parserContext);
                            if (type) paramType["type"] = type;
                        }
                        if (Object.keys(paramType).length > 0) {
                            if (paramType.type || paramType.items.type) {
                                // check if parameter type is a collection
                                if (objData.$Parameter[i].$Collection && !paramType.items) {
                                    obj[objType].params[objData.$Parameter[i].$Name] = {};
                                    obj[objType].params[objData.$Parameter[i].$Name].items = paramType;
                                    if(objData.$Parameter[i].$Nullable != true){
                                        obj[objType].params[objData.$Parameter[i].$Name].items["notNull"] = true;
                                    }
                                } else {
                                    obj[objType].params[objData.$Parameter[i].$Name] = paramType;
                                    if (!paramType.items) {
                                        if(objData.$Parameter[i].$Nullable != true){
                                            obj[objType].params[objData.$Parameter[i].$Name]["notNull"] = true;
                                        }
                                    }
                                }
                            }
                        } else {
                            let message = '"' + objData.$Parameter[i].$Type + '" is not supported (in element:"' + temp + '")';
                            console.log(warn(message));
                        }
                        if (obj[objType].params[objData.$Parameter[i].$Name])
                            Object.assign(obj[objType].params[objData.$Parameter[i].$Name], annotations)
                    }
                }
                // if parameters has no entries
                if (obj[objType].params && Object.keys(obj[objType].params).length === 0) {
                    delete obj[objType].params;
                }
                // add returns
                if (objData.$ReturnType && Object.keys(objData.$ReturnType).length > 0 && obj) {
                    let returnValue = {};
                    let annotations = {};
                    // check if the return type is pre-defined, undefined or custom defined
                    if (edmxncdsdatatype[objData.$ReturnType.$Type] || edmxncdsdatatype[objData.$ReturnType.$Type + "_a"]) {
                        returnValue = generatePropertyCsn(objData.$ReturnType, false);
                    } else {
                        let type = _getDatatype(objData.$ReturnType.$Type, parserContext);
                        _includeExternalNamespaceAnnotation(objData.$ReturnType, annotations);
                        if (type) returnValue["type"] = type;
                    }
                    if (Object.keys(returnValue).length > 0) {
                        if (returnValue.type || returnValue.items.type) {
                            obj[objType].returns = {};
                            // check if return type is a collection
                            if (objData.$ReturnType.$Collection && !returnValue.items) {
                                obj[objType].returns.items = {};
                                obj[objType].returns.items = returnValue;
                                if(objData.$ReturnType.$Nullable != true){
                                    obj[objType].returns.items["notNull"] = true;
                                }
                            } else {
                                obj[objType].returns = returnValue;
                                if (!returnValue.items) {
                                    if(objData.$ReturnType.$Nullable != true){
                                    obj[objType].returns["notNull"] = true;
                                }
                                }
                            }
                        }
                    }
                    else {
                        let message = '"' + objData.$ReturnType.$Type + '" is not supported (in return type of' + temp + ')';
                        console.log(warn(message));
                    }
                    if (obj[objType].returns)
                        Object.assign(obj[objType].returns, annotations);
                }
            }
            unboundedObj = Object.assign(unboundedObj, obj);
        });
    }
    return unboundedObj;
}

function _generateCSN(edmxAsJson, ignorePersistenceSkip, mockServerUc, parserContext) {
    let csn = {};
    let schemaData = [];
    csn.meta = {};
    csn.meta.creator = 'cds-dk ' + versionInfo;
    csn.$version = '2.0';
    csn.definitions = {};

    Object.keys(edmxAsJson).forEach(data => {
        if (ignoreObjects.indexOf(data) === -1 && edmxAsJson[data] instanceof Object) {
            // replace the namespace alias value with original namespace value
            if (edmxAsJson[data].$Alias)
                edmxAsJson[data] = common.replaceAliasValue(JSON.stringify(edmxAsJson[data]), data, edmxAsJson[data].$Alias);
            schemaData.push(edmxAsJson[data]);
        }
    });

    if (mockServerUc) {
        let entitySetData = edmxAsJson[parserContext.namespace];
        let entityContainer;
        Object.keys(entitySetData).forEach(data => {
            if (ignoreObjects.indexOf(data) === -1 && entitySetData[data] instanceof Object) {
                if (entitySetData[data].$Kind && entitySetData[data].$Kind === 'EntityContainer') {
                    entityContainer = entitySetData[data];
                }
            }
        });
        Object.keys(entityContainer).forEach(data => {
            if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Type && (entityContainer[data].$Collection || entityContainer[data].$Singleton)) {
                parserContext.entitySetToEntityTypeMap.set(entityContainer[data].$Type, data);
            } else if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Action) {
                parserContext.actionImportToActionMap.set(entityContainer[data].$Action, data);
                parserContext.unboundedActions[entityContainer[data].$Action] = entitySetData[data];
            } else if (ignoreObjects.indexOf(data) === -1 && entityContainer[data] instanceof Object &&
                entityContainer[data].$Function) {
                parserContext.functionImportToFunctionMap.set(entityContainer[data].$Function, data);
                parserContext.unboundedFunctions[entityContainer[data].$Function] = entitySetData[data];
            }
        });
    }

    csn.definitions[parserContext.namespace] = {};
    csn.definitions[parserContext.namespace].kind = 'service';
    csn.definitions[parserContext.namespace]['@cds.external'] = true;

    _collectEnumType(schemaData, parserContext);
    _collectTypeDefinition(schemaData, parserContext);
    _collectBounded(schemaData, 0, parserContext);
    _collectBounded(schemaData, 1, parserContext);

    // Step 1: get all complex types.
    csn.definitions = Object.assign(_generateCSNForComplexType(schemaData, parserContext), csn.definitions);
    // Step 2: get all type definition
    csn.definitions = Object.assign(_parseTypeDefinition(parserContext), csn.definitions);
    // Step 3: get all entity type
    csn.definitions = Object.assign(_parseEntityType(schemaData, ignorePersistenceSkip, mockServerUc, parserContext), csn.definitions);
    // Step 4: get all unbounded action & function
    csn.definitions = Object.assign(_parseUnbounded(schemaData, 0, parserContext), csn.definitions);
    csn.definitions = Object.assign(_parseUnbounded(schemaData, 1, parserContext), csn.definitions);
    // Step 5: get all enum types
    csn.definitions = Object.assign(_generateCSNForEnumType(schemaData, parserContext), csn.definitions);
    // Step 6: add entity container properties
    csn.definitions = Object.assign(_parseEntityContainer(csn.definitions, schemaData, parserContext, parserContext), csn.definitions);
    // Step 7: get all bounded action & function
    _parseBounded(csn.definitions, 0, parserContext);
    _parseBounded(csn.definitions, 1, parserContext);
    // Step 8: get all annotations
    _generateDocumentation(edmxAsJson, schemaData, csn.definitions, parserContext);

    return JSON.stringify(csn, null, 4);
}

function _replaceSpecialCharacters(text) {
    return text.replace(/(?:\\[rn]|[\r\n]+)+/gm, "\n").replace(/\s+/g, ' ').replace(/"/g, "&quot;").trim();
}

function _checkAnnotatationTerm(annotation, path, no_of_terms, targetString, vocab) {
    if (path) {
        if (targetString === "@Core.Description" && annotation[1]["@Core.Description"]) {
            if (path.doc === undefined)
                path.doc = _replaceSpecialCharacters(annotation[1]["@Core.Description"]);
            else
                path.doc += _replaceSpecialCharacters(annotation[1]["@Core.Description"]);
        }
        else if (targetString === "@Core.LongDescription" && annotation[1]["@Core.LongDescription"]) {
            _generateLongDescription(annotation, path, no_of_terms);
        }
        else if (targetString === "@Core.OptionalParameter" && annotation[1]["@Core.OptionalParameter"]) {
            _captureOptionalParameter(annotation, path);
        }
        else if (vocab) { 
            if (vocab.includes(targetString.substring(targetString.indexOf('@') + 1, targetString.lastIndexOf('.')))) {
                path[targetString] = annotation[1][targetString] === null ? true : annotation[1][targetString];
            }
        }
    }
}

function checkEntitySetMap(pathName, parserContext, index = 0) {
    if (parserContext.entitySetToEntityTypeMap.get(pathName) != null) {
        pathName = parserContext.namespace + '.' + parserContext.entitySetToEntityTypeMap.get(pathName)[index];
    }
    return pathName;
}

function _checkAnnotationTarget(annotation, cdsDefs, str, no_of_terms, vocab, parserContext) {
    if ((annotation[0].indexOf('/') === -1 && annotation[0].indexOf('(') === -1) || annotation[0].includes("Container")) {
        if (cdsDefs[annotation[0]]) {
            let path = annotation[0].split('/');
            let pathFromEntityTypeMap = parserContext.entitySetToEntityTypeMap.get(path[0]);
            if (pathFromEntityTypeMap != null) {
                if (pathFromEntityTypeMap.length > 1) {
                    for (let index = 0; index < pathFromEntityTypeMap.length; index++) {
                        let path1 = checkEntitySetMap(path[0], parserContext, index);
                        _checkAnnotatationTerm(annotation, cdsDefs[path1], no_of_terms, str, vocab);
                    }
                } else {
                    _checkAnnotatationTerm(annotation, cdsDefs[annotation[0]], no_of_terms, str, vocab);
                }
            }
            else {
                _checkAnnotatationTerm(annotation, cdsDefs[annotation[0]], no_of_terms, str, vocab);
            }
        }
        if (annotation[0].indexOf('/') > 0) {
            let path = annotation[0].split('/');
            let temp = parserContext.namespace + '.' + path[1];
            let path1 = checkEntitySetMap(temp, parserContext);
            if (cdsDefs[path1]) {
                _checkAnnotatationTerm(annotation, cdsDefs[path1], no_of_terms, str, vocab);
            }
        }
        else if (annotation[0].includes("Container")) {
            let path = annotation[0].substring(0, annotation[0].lastIndexOf('.'));
            let actualPath = checkEntitySetMap(path, parserContext);
            _checkAnnotatationTerm(annotation, cdsDefs[actualPath], no_of_terms, str, vocab);
        }
        else if (annotation[0].indexOf('(') === -1 && (annotation[0].indexOf('/') === -1)) {
            let path = annotation[0].split('/');
            let pathFromEntityTypeMap = parserContext.entitySetToEntityTypeMap.get(path[0]);
            if (pathFromEntityTypeMap != null) {
                if (pathFromEntityTypeMap.length > 1) {
                    for (let index = 0; index < pathFromEntityTypeMap.length; index++) {
                        let path1 = checkEntitySetMap(path[0], parserContext, index);
                        _checkAnnotatationTerm(annotation, cdsDefs[path1], no_of_terms, str, vocab);
                    }
                }
            }
        }
    }
    else if (annotation[0].indexOf('(') === -1 && !(annotation[0].indexOf('/') === -1)) {
        let path = annotation[0].split('/');
        let pathFromEntityTypeMap = parserContext.entitySetToEntityTypeMap.get(path[0]);
        if (pathFromEntityTypeMap != null) {
            if (pathFromEntityTypeMap.length > 1) {
                for (let index = 0; index < pathFromEntityTypeMap.length; index++) {
                    let path1 = checkEntitySetMap(path[0], parserContext, index);
                    _checkAnnotatationTerm(annotation, cdsDefs[path1]["elements"][path[1]], no_of_terms, str, vocab);
                }
            }
            else {
                let path1 = checkEntitySetMap(path[0], parserContext);
                if (cdsDefs[path1]) {
                    _checkAnnotatationTerm(annotation, cdsDefs[path1]["elements"][path[1]], no_of_terms, str, vocab);
                }
            }
        }
        else {
            if (cdsDefs[path[0]]) {
                _checkAnnotatationTerm(annotation, cdsDefs[path[0]]["elements"][path[1]], no_of_terms, str, vocab);
            }
        }
    }
    else {
        let path = annotation[0].split('(');
        let actualPath = checkEntitySetMap(path[0], parserContext);
        if (cdsDefs[actualPath] === undefined) {
            let temp = path[1].split(')');
            let path1 = temp[0].split(',');
            let path2 = path[0].split('.');
            if (cdsDefs[path1[0]]) {
                _checkAnnotatationTerm(annotation, cdsDefs[path1[0]]["actions"][path2[1]], no_of_terms, str, vocab);
            }
        } else {
            if (path[1].indexOf('/') === -1) {
                _checkAnnotatationTerm(annotation, cdsDefs[path[0]], no_of_terms, str, vocab);
            } else {
                let path1 = path[1].split('/');
                if (cdsDefs[path[0]] && cdsDefs[path[0]]["params"]) {
                    _checkAnnotatationTerm(annotation, cdsDefs[path[0]]["params"][path1[1]], no_of_terms, str, vocab);
                }
            }
        }
    }
}

function _replaceSchemaDataAnnotation(vocabAlias, vocabNamespce, schemaDataAnnotation) {
    for (let v in vocabAlias) {
        if (schemaDataAnnotation.includes(vocabAlias[v])) {
            schemaDataAnnotation = schemaDataAnnotation.split(vocabAlias[v]).join(known_vocabularies[vocabNamespce[v]]);
        }
        if (schemaDataAnnotation.includes(vocabNamespce[v])) {
            schemaDataAnnotation = schemaDataAnnotation.split(vocabNamespce[v]).join(known_vocabularies[vocabNamespce[v]]);
        }
    }
    return JSON.parse(schemaDataAnnotation);
}

function _generateDocumentation(edmxAsJson, schemaData, cdsDefs, parserContext) {
    let vocabAlias = [];
    let vocab = [];
    let vocabNamespce = [];
    let controlFieldFlag = 0;
    if (schemaData[0].$Annotations) {
        if (edmxAsJson.$Reference) {
            Object.entries(edmxAsJson.$Reference).forEach(a => {
                if (known_vocabularies.hasOwnProperty(a[1].$Include[0].$Namespace)) {
                    vocabAlias.push(a[1].$Include[0].$Alias);
                    vocabNamespce.push(a[1].$Include[0].$Namespace);
                    vocab.push(known_vocabularies[a[1].$Include[0].$Namespace])
                }
            });
        }

        schemaData[0].$Annotations = _replaceSchemaDataAnnotation(vocabAlias, vocabNamespce, JSON.stringify(schemaData[0].$Annotations));

        Object.entries(schemaData[0].$Annotations).map(annotation => {
            let no_of_terms;
            Object.entries(annotation[1]).forEach(anno => {
                if (vocab.includes(anno[0].substring(anno[0].indexOf('@') + 1, anno[0].lastIndexOf('.')))) {
                    if (annotation[1].hasOwnProperty('@Core.Description')) {
                        no_of_terms = true;
                    }
                    if (annotation[1].hasOwnProperty('@Common.FieldControl') && controlFieldFlag === 0) {
                        annotation[1]["@Common.FieldControl"] = { "#": annotation[1]["@Common.FieldControl"]}
                        controlFieldFlag = 1;
                    }
                    if (annotation[1].hasOwnProperty('@Common.IsUpperCase')) {
                        annotation[1]["@Common.IsUpperCase"] = true;
                    }
                    _checkAnnotationTarget(annotation, cdsDefs, anno[0], no_of_terms, vocab, parserContext);
                }
            });
            controlFieldFlag = 0;
        });
    }
}

function _generateLongDescription(annotation, path, no_of_terms) {
    if (path) {
        path.doc = no_of_terms ? (path.doc += "\n\n") : (path.doc ? (path.doc += "") : (path.doc = ""));
        path.doc += _replaceSpecialCharacters(annotation[1]["@Core.LongDescription"]);
        return (path.doc);
    }
}

function _generateEDMX2JSON(edmx, name_space, parserContext) {
    return new Promise(function getJson(resolve, reject) {
        try {
            const inputBuffer = edmx;
            // create converter
            const v4Conv = MetadataConverterFactory.createEdmxV40XmlToV40Json(name_space);
            v4Conv.execute(inputBuffer, (error, json, missingReferencedDocuments) => {
                if (missingReferencedDocuments?.length > 0) {
                    console.log(missingReferencedDocuments); // eslint-disable-line no-console
                }
                if (_isValidJSON(json, parserContext)) {
                    resolve(json);
                }
            });
        } catch (err) {
            reject(err);
        }
    });
}

async function getEdmxv4CSN(edmx, ignorePersistenceSkip, mockServerUc, context) {
    let csn;
    let edmjConverted;
    let name_space = []

    const parserContext = {};
    _initialize(parserContext);

    if (context.include_all_namespaces === true)
        name_space.push(true);
    else
        name_space = context.namespaces;

    if (_isJson(edmx)) {
        return new Promise(function getCsn(resolve, reject) {
            try {
                edmjConverted = JSON.parse(edmx);
                if (_isValidJSON(edmjConverted, parserContext)) {
                    csn = _generateCSN(edmjConverted, ignorePersistenceSkip, mockServerUc, parserContext);
                    if (csn) resolve(csn);
                }
            } catch (err) {
                reject(err);
            }
        });
    }
    const edmj = await _generateEDMX2JSON(edmx, name_space, parserContext);
    return _generateCSN(edmj, ignorePersistenceSkip, mockServerUc, parserContext);
}

module.exports = {
    getEdmxv4CSN
};
