const DEBUG = /\b(y|all|cli|watch)\b/.test(process.env.DEBUG) && console.debug

module.exports = ({ cwd, script, ext, includes=RegExp(), ignore=RegExp(), env={}, delay=200, options={} })=>{

  let child

  // Phoning home...
  const EventEmitter = require('events')
  const emitter = new EventEmitter

  const killAndExit = (sig) => {
    DEBUG && DEBUG('\nreceived signal:', sig)
    _kill (child, process.exit)
  }
  process.on('SIGTERM', killAndExit)
  process.on('SIGINT', killAndExit)

  // Re-starting child process...
  const { fork } = require('child_process')
  const restart = _coalesceEvents(delay, (events) => {
    DEBUG && DEBUG('>> Events:', events)
    _kill (child, () => {
      DEBUG && console.trace('Restart')
      const execArgv = [...process.execArgv]
      events.forEach(evt => {
        if (evt.type && evt.type.startsWith('--')) execArgv.push(evt.type)
        if (evt.name && evt.name.startsWith('--')) execArgv.push(evt.name)
      })
      if (options.debug) execArgv.push('--inspect')
      if (options['debug-brk']) execArgv.push('--inspect-brk')

      const updated = events.filter(evt => evt.type && evt.type === 'update').map(evt => evt.name)
      emitter.emit ('restart', updated)
      child = fork (script, { cwd, env, stdio:'inherit', execArgv }, (err)=>{
        if (err)  console.error (err)
      })
      child.on('message', msg => {
        if (msg === 'restart') return restart()
        emitter.emit('message', msg)
      })
    })

  })

  restart()

  // Watching for touched files...
  const watch = require('node-watch')
  const include = RegExp(`\\.(${ext.replace(/,/g,'|')})$|${includes.source}`)
  const filter = f => !ignore.test(f) && include.test(f)
  watch (cwd||process.cwd(),{ recursive:true, filter, delay:0 }, restart)

  // Live commands...
  const readline = require('readline')
  readline.createInterface(process.stdin).on('line', (input) => {
    if (input === '') restart()
    else if (input === 'restart' || input === 'rs' || input.match(/^y$/i)) restart()
    else if (input === 'debug' || input === 'dbg')  restart('--inspect')
    else if (input === 'break' || input === 'brk')  restart('--inspect-brk')
    else if (input === 'debug-brk')  restart('--inspect-brk')
    else if (input === 'ps') ps(child,env)
    else if (input === 'bye' || input.match(/^n$/i)) { _kill (child, () => process.exit())  }
    else console.log ('?\n')
  })

  emitter.restart = restart
  emitter.stop    = () => _kill(child, () => false)
  emitter.setEnv  = (name, value) => {
    if (typeof value === "undefined") {
      delete env[name]
    } else {
      env[name]
    }
  }
  return emitter
}

const ps = (child,env) => console.log (`\x1b[32m
  PID     Process   Command
  ${process.pid}   parent    cds ${process.argv.slice(2).join(' ')}
  ${  child.pid}   child     cds ${JSON.parse(env._args).join(' ')}
  \x1b[0m`
)

// reduces mutiple node-watch events in a time frame into a bulk
function _coalesceEvents(delay, fn) {
  let timer, cache = []
  function handle() {
    fn(cache)
    timer = null
    cache = []
  }
  return function(type, name) { // node-watch callback signature
    cache.push({type, name})
    if (!timer) {
      timer = setTimeout(handle, delay);
    }
  }
}

/*
 * Ensures the given child process gets killed in different environments
 */
function _kill (proc, cb=()=>{}) {
  if (!proc)  return cb()
  if (proc[_pending])  return // safeguard against repeated calls for the same process
  proc[_pending] = true
  const fn = () => { delete proc[_pending]; return cb(); }

  const waitTime = parseInt(process.env.CDS_WATCH_KILL_DELAY) || 500
  // On Windows, child_process.kill() abruptly kills the process (https://nodejs.org/api/child_process.html#subprocesskillsignal)
  // Server has cleanup code to run, so send a custom message and give it a bit time.
  if (process.platform === 'win32') {
    proc.send({ close: true }, () => {})  // see @sap/cds/bin/serve.js
    setTimeout(()=> {
      proc.kill()
      DEBUG && DEBUG('Killed process', proc.pid)
      fn()
    }, waitTime)
    return
  }

  // first kill normally (using SIGTERM)
  let killed = false
  proc.on('exit',() => {
    if (!killed) { killed = true
      DEBUG && DEBUG('Killed process', proc.pid)
      fn()
    }
  }).kill()

  // fallback for misbehaving processes: SIGKILL it after some time
  setTimeout(()=> {
    if (!killed) { killed = true
      proc.kill('SIGKILL')
      DEBUG && DEBUG('Killed process (forcefully)', proc.pid)
      fn()
    }
  }, waitTime)
}

const _pending = Symbol.for('sap.cds.watch.pendingKill')
