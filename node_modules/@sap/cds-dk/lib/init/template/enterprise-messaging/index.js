const { join } = require('path')
const ProjectReader = require('../../util/projectReader')
const { mergeJSON, mergeYAML } = require('../../util/merge')
const { copyAndTrack, parseMd5File, writeMd5File } = require('../../util/md5Tracking')
const { srvNode, srvJava, enterpriseMessaging } = require('../_merging/registry-mta')

module.exports = class EnterpriseMessagingTemplate extends require('../templateBase') {
  constructor(projectPath, generator) {
    super(projectPath, generator, __dirname)
    this.projectReader = new ProjectReader(projectPath)
  }

  static hasFacet(env) {
    return env.requires?.messaging === 'enterprise-messaging'
  }

  async run() {
    const projectDescriptor = await this.projectReader.read(this.options)
    const { for: forProfile, isNodejs } = projectDescriptor.cap
    const templatePath = join(__dirname, 'files')
    const cdsTemplateFile = (isNodejs ? 'cds.package.json' : 'cdsrc.json') + (forProfile ? '.hbs' : '')
    const cdsTemplatePath = join(templatePath, cdsTemplateFile)
    const configPath = join(this.projectPath, isNodejs ? 'package.json' : '.cdsrc.json')
    await mergeJSON(configPath, cdsTemplatePath, projectDescriptor)
    await this.runDependentMerging()
  }

  async runDependentMerging(context = {}) {
    const projectDescriptor = await this.projectReader.read(this.options)
    const { hasHelm, hasMta, isNodejs } = projectDescriptor.cap

    if (hasMta) {
      const mtaYAMLPath = join(this.projectPath, 'mta.yaml')
      const srv = isNodejs ? srvNode : srvJava
      await mergeYAML(
          mtaYAMLPath,
          join(__dirname, 'files', 'mta.yaml.hbs'),
          projectDescriptor,
          {
              additions: [srv, enterpriseMessaging],
              relationships: [{
                  insert: [enterpriseMessaging, 'name'],
                  into: [srv, 'requires', 'name']
              }]
          }
      )
      await mergeJSON(
        join(this.projectPath, 'event-mesh.json'),
        join(__dirname, 'files', 'event-mesh.json.hbs'),
        projectDescriptor
      )
    }

    if (hasHelm) {
      //in case facet is being added to the already exisiting charts folder
      let isIndependentCommand = false
      if(Object.keys(context).length == 0){
          isIndependentCommand = true
          context.projectPath = this.projectPath
          context.oldTrackingData = context.newTrackingData = await parseMd5File(join(this.projectPath, 'chart', '.cds-add-helm-files.md5'))
      }
      await mergeYAML(
        join(this.projectPath, 'chart', 'values.yaml'),
        join(__dirname, 'files', 'values.yaml')
      )
      await copyAndTrack(
         join(__dirname, 'files', 'event-mesh.yaml'),
         join(this.projectPath, 'chart', 'templates', 'event-mesh.yaml'),
         context
      )
      if(isIndependentCommand) await writeMd5File(join(this.projectPath, 'chart', '.cds-add-helm-files.md5'), context.newTrackingData)
    }
  }
}
