const cds = require('../../cds');
const path = require('path');

const { PROJECT_TYPE } = require('../constants');
const { exists } = require('../../cds').utils;

module.exports = class TemplateBase {
    /**
     * @constructor
     */
    constructor(projectPath, generator, dirName) {
        if (generator.options && generator.options.for && typeof generator.options.for !== 'string') {
            throw new Error('The --for argument must not be empty.')
        }
        this.projectPath = path.resolve(projectPath);
        this.options = generator.options || {};
        this.projectPath = path.resolve(projectPath);
        this.generator = generator;

        this.cwd = this.options.cwd || process.cwd();
        this.name = (dirName ? path.basename(dirName) : this.constructor.name.replace(/template/i, '').toLowerCase());

        this.projectName = path.basename(this.projectPath);
    }

    /**
     * Returns an array of required templates. These templates will also be added if not already included.
     * @returns an array with depending templates, might be empty or null
     */
    getDependencies() {
    }

    /**
     * Checks whether the given template should handle this request
     * @returns true, if template should handle this request, false otherwise
     * @throws Error, if request is invalid, e.g. a file exists already
     */
    async canRun() {
        return true;
    }

    // eslint-disable-next-line no-unused-vars
    static hasFacet(env, projectPath, options) {
        return true;
    }

    /**
     * calls cds env and caches result
     * @returns {object} the current cds env
     */
     async getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return cds.env.for('cds', exists(this.projectPath) ? this.projectPath : this.cwd);
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    /**
     * @abstract
     * Executes the given template's merging steps which are dependent on another template.
     * The separation from `run()` is necessary to preserve templating associativity,
     * i.e. the order in which you apply them does not matter.
     * Ex.: Assume `cds add hana` is called before `cds add mta`. We want `cds add mta`
     * to create the base mta.yaml template and merge the hana mta.yaml in, but _don't_
     * want any other steps from the hana template performed (e.g. creating the .hdiconfig).
     * Separating the two let's us run this _only_ the merging part of the template.
     * In addition, this partial merging avoids cyclic template dependencies.
     */
    async runDependentMerging() {

    }

    /**
     * @abstract
     * Executes the given template.
     * @throws Error, if handling failed.
     */
    async run() {
    }

    /**
     * @abstract
     * Called when generation is finished
     */
    async finalize() {
    }

    /**
     * Returns the project type
     * @see PROJECT_TYPE
     * @returns PROJECT_TYPE for current project
     */
    async getProjectType() {
        if (exists(path.join(this.projectPath, 'pom.xml'))) {
            return PROJECT_TYPE.java;
        }

        if (exists(path.join(this.projectPath, 'package.json'))) {
            return PROJECT_TYPE.nodejs;
        }

        return PROJECT_TYPE.unknown;
    }
}
