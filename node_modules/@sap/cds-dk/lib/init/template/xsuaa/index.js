const { join } = require('path')
const ProjectReader = require('../../util/projectReader')
const { mergeJSON, mergeYAML } = require('../../util/merge')
const { copyAndTrack, parseMd5File, writeMd5File } = require('../../util/md5Tracking')
const { srvNode, srvJava, xsuaa, mtxSidecar } = require('../_merging/registry-mta')
const { PROJECT_TYPE } = require('../../constants')

module.exports = class XsuaaTemplate extends require('../templateBase') {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname)
        this.projectReader = new ProjectReader(projectPath)
    }

    static hasFacet(env) {
        return env.requires?.auth?.kind === 'xsuaa'
    }

    async run() {
        const { projectPath } = this
        const templatePath = join(__dirname, 'files')
        const projectDescriptor = await this.projectReader.read(this.options)
        const projectType = await this.getProjectType();
        const { for: forProfile } = projectDescriptor.cap

        if (projectType === PROJECT_TYPE.java) {
            const cdsrcJSONPath = join(projectPath, '.cdsrc.json')
            const cdsTemplateFile = forProfile ? 'cds.cdsrc.json.hbs' : 'cds.cdsrc.json'
            const cdsTemplatePath = join(templatePath, cdsTemplateFile)
            await mergeJSON(cdsrcJSONPath, cdsTemplatePath, projectDescriptor)
        } else if (projectType === PROJECT_TYPE.nodejs) {
            const packageJSONPath = join(projectPath, 'package.json')
            const cdsTemplateFile = forProfile ? 'cds.package.json.hbs' : 'cds.package.json'
            const cdsTemplatePath = join(templatePath, cdsTemplateFile)
            await mergeJSON(packageJSONPath, cdsTemplatePath, projectDescriptor)
            const dependenciesTemplatePath = join(templatePath, 'dependencies.package.json')
            await mergeJSON(packageJSONPath, dependenciesTemplatePath)
        }

        await this.runDependentMerging()
    }

    async runDependentMerging( context = {}) {
        const projectDescriptor = await this.projectReader.read(this.options)
        const { isMultitenant, isExtensible, hasMta, hasHelm, isNodejs, isJava } = projectDescriptor.cap

        const cds = require('../../../../lib/compile')
        const xsSecurity = await (async () => { try {
            const models = await cds.load(join(this.projectPath, cds.env.folders.srv))
            return cds.compile.to.xsuaa(models)
        } catch (error) { /* ignore */ }
        })() || { scopes: [], attributes: [], 'role-templates': [], 'authorities-inheritance': false }
        const mergingSemantics = { additions: xsSecurity.scopes.map(scope => ({
            ref: scope.name,
            in: 'scopes',
            where: [{
                property: 'name',
                isEqualTo: scope.name
            }],
        }))}
        const xsSecurityPath = join(this.projectPath, 'xs-security.json')
        await mergeJSON(xsSecurityPath, xsSecurity, projectDescriptor, mergingSemantics)

        if (hasMta) {
            const srv = isNodejs ? srvNode : srvJava
            const additions = [srv, xsuaa]
            if (isMultitenant && isJava) additions.push(mtxSidecar)

            const mtaYAMLPath = join(this.projectPath, 'mta.yaml')
            const relationships =  [{
                insert: [xsuaa, 'name'],
                into: [srv, 'requires', 'name']
            }]
            relationships.push({
                insert: [xsuaa, 'name'],
                into: [mtxSidecar, 'requires', 'name']
            })

            await mergeYAML(
                mtaYAMLPath,
                `${__dirname}/files/mta.yaml.hbs`,
                projectDescriptor,
                {
                    additions,
                    relationships
                }
            )
        }

        if (hasHelm) {
            //in case facet is being added to the already exisiting charts folder
            let isIndependentCommand = false;
            if(Object.keys(context).length == 0){
                isIndependentCommand = true;
                context.projectPath = this.projectPath;
                context.oldTrackingData = context.newTrackingData = await parseMd5File(join(this.projectPath, 'chart', '.cds-add-helm-files.md5'));
            }
            await copyAndTrack(
                join(__dirname, 'files', 'xsuaa.yaml'),
                join(this.projectPath, 'chart', 'templates', 'xsuaa.yaml'),
                context
            )
            await mergeYAML(
                join(this.projectPath, 'chart', 'values.yaml'),
                join(__dirname, 'files', 'values.yaml.hbs'),
                projectDescriptor
            )
            // REVISIT: Shared xs-security.json location for Helm and MTA?
            await copyAndTrack(
                join(this.projectPath, 'xs-security.json'),
                join(this.projectPath, 'chart', 'xs-security.json'),
                context
            )
            if(isIndependentCommand) await writeMd5File(join(this.projectPath, 'chart', '.cds-add-helm-files.md5'), context.newTrackingData);
        }

        // Re-applying the merging part of `cds add mtx` because cds.compile.to.xsuaa
        // has overwritten the existing `xs-security.json`.
        // TODO: Find a generic solution for situation like these.
        if (isMultitenant) {
            const MultitenancyTemplate = require(`../multitenancy`)
            const multitenancyTemplate = new MultitenancyTemplate(this.projectPath, this.generator)
            await multitenancyTemplate.runDependentMerging(context)
        }

        if (isExtensible) {
            const ExtensibilityTemplate = require(`../extensibility`)
            const extensibilityTemplate = new ExtensibilityTemplate(this.projectPath, this.generator)
            await extensibilityTemplate.runDependentMerging(context)
        }
    }
}
