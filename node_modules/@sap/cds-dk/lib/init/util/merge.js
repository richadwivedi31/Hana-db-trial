const YAML = require('@sap/cds-foss').yaml
const { copy, read, write, exists } = require('../../cds').utils
const { readYAML, writeYAML, readJSON } = require('./fsUtil')

function _isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item)
}

function _deepMerge(target, source) {
  const unique = array => [...new Set(array.map(JSON.stringify))].map(JSON.parse)
  if (_isObject(target) && _isObject(source)) {
      for (const key in source) {
          if (_isObject(source[key])) {
              if (!target[key]) Object.assign(target, { [key]: source[key] })
              else _deepMerge(target[key], source[key])
          } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
              target[key] = unique([...source[key], ...target[key]])
          } else {
              Object.assign(target, { [key]: target[key] || source[key] })
          }
      }
  } else if (Array.isArray(target) && Array.isArray(source)) {
      target = unique([...source, ...target])
  }
  return target ?? source
}

async function sortDependencies(packageJSONPath) {
  const json = await read(packageJSONPath);
  json.dependencies = Object.fromEntries(
      Object.entries(json.dependencies).sort(([a],[b]) => a>b ? 1 : -1)
  )
  await write(packageJSONPath, json, { spaces: 2 });
}

async function mergeJSON(into, from, projectDescriptor, semantics) {
    const source = typeof from === 'string' ? await readJSON(from, projectDescriptor) : from

    if (typeof into === 'string' && !exists(into)) {
        return write(into, source, { spaces: 2 })
    }

    let result
    if (semantics) {
        const target = await read(into)
        const targetYAML = YAML.parseDocument(YAML.stringify(target))
        const sourceYAML = YAML.parseDocument(YAML.stringify(source))
        const resultYAML = await mergeYAML(targetYAML, sourceYAML, projectDescriptor, semantics)
        result = YAML.parse(YAML.stringify(resultYAML))
    } else {
        const target = typeof into === 'string' ? await read(into) : into
        result = _deepMerge(target, source)
    }
    if (typeof into === 'string') await write(into, result, { spaces: 2 })
    return result
}

async function mergeYAML(into, from, projectDescriptor, semantics = {}) {
    const target =
        typeof into === 'string' ? await readYAML(into) :
        into instanceof YAML.Document ? into :
        new YAML.Document(into)
    const source =
        typeof from === 'string' ? await readYAML(from, projectDescriptor)
        : from instanceof YAML.Document ? from :
        new YAML.Document(from)

    if (!target || !target.contents) {
        if (typeof into === 'string' && typeof from === 'string') {
            return projectDescriptor ? writeYAML(into, source) : copy(from, into)
        }
        return /* has no YAML */
    }

    const existenceMap = new Map, templateExistenceMap = new Map()

    const { additions, overwrites, deletions, relationships } = semantics
    additions?.forEach(existence => {
        existenceMap.set(existence.ref, undefined)
        templateExistenceMap.set(existence.ref, undefined)
    })
    deletions?.forEach(deletion => {
        existenceMap.set(deletion.item.ref, undefined)
    })
    relationships?.forEach(relationship => {
        const [existence] = relationship.into
        const [insertExistence] = relationship.insert
        const ref = insertExistence.ref + ' -> ' + existence.ref
        existenceMap.set(ref, undefined)
    })

    let collectionStack = [target.contents]

    const _getProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p[k], object)
    const _getYAMLProperty = (object, keyPath) => keyPath.split('.').reduce((p, k) => p && p.get(k), object)

    const _validateWhere = (node, dict, index) => {
        const _addToMap = existences => existences?.filter(existence => {
                let where = existence.in
                if (typeof where === 'string') return true // just a key path on the document root
                else where = where[0] // a more complex list of constraints, a sequence/array is involved
                const neededParent = dict.get(where.ref)?.node
                return collectionStack.includes(neededParent) // lookbehind in parent collection stack
                // REVISIT: Only look behind until sequence is reached?
        }).forEach(({ where, ref }) => {
            const json = JSON.parse(String(node))
            const whereFulfilled = where.every(constraint =>
                constraint.isEqualTo === _getProperty(json, constraint.property)
            )
            if (whereFulfilled) {
                const [collection] = collectionStack
                dict.set(ref, { json, node, index, collection })
            }
        })
        if (additions) _addToMap(additions)
        if (deletions) _addToMap(deletions.map(deletion => deletion.item))
        if (relationships) _addToMap(relationships?.map(({into: [existence]}) => existence).filter(e => e))
    }

    function _traverseYAMLNode(node, index, actions, templateNode) {
        let shifted = false
        if (YAML.isMap(node)) {
            actions?.visitMap && actions.visitMap(node, index)
            const [collection] = collectionStack
            if (YAML.isSeq(collection)) {
                collectionStack.unshift(node)
                shifted = true
            }
        } else if (YAML.isPair(node) && node.value?.items) {
            collectionStack.unshift(node.value)
        } else if (YAML.isScalar(node) && semantics.forceOverwrite && templateNode) {
            node.value = templateNode.value ?? templateNode.items?.[0]?.value?.value
        }

        if (node.items) {
            if (YAML.isSeq(node) && templateNode?.items) {
                actions?.mergeCollection && actions.mergeCollection(node, templateNode)
                _traverseYAMLCollection(node, actions, templateNode)
            } else {
                _traverseYAMLCollection(node, actions, templateNode)
            }
        } else if (node.value?.items || node.value && semantics.forceOverwrite) {
            _traverseYAMLNode(node.value, index, actions, templateNode && templateNode.value)
        }

        if (node.value?.items || shifted) {
            collectionStack.shift()
        }
    }
    _traverseYAMLNode.bind(this)

    function _traverseYAMLCollection (collection, actions, templateCollection) {
        if (!collection) return

        const keyToIndex = new Map, templateIndexToIndex = new Map

        // Map collection items to their semantic counterpart(s)
        collection.items.forEach((node, i) => {
            if (node.key) keyToIndex.set(node.key.value, i)
            const existence = [...existenceMap.entries()].find(([,value]) => value?.node === node)
            if (existence) {
                const [existenceKey] = existence
                const templateExistence = existenceKey && templateExistenceMap.get(existenceKey)
                const templateIndex = templateExistence?.index
                if (templateIndex !== undefined) templateIndexToIndex.set(templateIndex, i)
            }
            if (!templateCollection) _traverseYAMLNode(node, i, actions)
        })

        if (!templateCollection) return

        templateCollection.items.forEach((templateNode, templateIndex) => {
            if (YAML.isScalar(templateNode)) {
                if (!collection.items.map(item => item.value).includes(templateNode.value)) {
                    collection.add(templateNode)
                }
            } else if (YAML.isPair(templateNode)) {
                const i = keyToIndex.get(templateNode.key.value)
                const [collection] = collectionStack
                const targetNode = collection.items && collection.items[i]
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                } else if (actions.mergePair) {
                    actions.mergePair(collection, templateNode)
                }
            } else if (YAML.isMap(templateNode)) {
                const targetNode = collection.items[templateIndexToIndex.get(templateIndex)]
                if (actions.mergeCollection) actions.mergeCollection(targetNode, templateNode)
                if (targetNode) {
                    _traverseYAMLNode(targetNode, templateIndex, actions, templateNode)
                }
            }
        })
    }
    _traverseYAMLCollection.bind(this)

    // 1. Validate the existences in the template
    _traverseYAMLNode(source.contents, null, {
        visitMap: (node, index) => {
            _validateWhere(node, templateExistenceMap, index)
        }
    })

    // 2. Validate the existences in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => {
            _validateWhere(node, existenceMap, index)
        }
    })

    // 3. Apply overwrites to already found existences
    overwrites?.forEach(({ item, withValue }) => {
        const keyPath = Array.isArray(item) && typeof item[0] === 'string' ? item[0] : typeof item === 'string' ? item : item[1]
        const inExistence = Array.isArray(item) && typeof item[0] === 'object' ? item[0] : typeof item === 'object' ? item : item[1]
        const node = inExistence && existenceMap.get(inExistence.ref) ? existenceMap.get(inExistence.ref).node : collectionStack[collectionStack.length - 1]
        const keys = keyPath.split('.')
        if (!node.getIn(keys)) return
        _getYAMLProperty(node, keys.slice(0, keys.length - 1).join('.'))
            .set(keys[keys.length - 1], withValue)
    })

    // 4. Delete existences from the project (e.g. separate deployer module when adding mtx)
    deletions?.forEach(({ item: { ref }, relationships }) => {
        const existence = existenceMap.get(ref)
        if (!existence) return
        existence.collection.delete(existence.index)

        relationships?.forEach(relationship => {
            const [allWithinKeyPath, inKeyPath, into] = relationship.allWithin
            const parent = _getYAMLProperty(target, allWithinKeyPath)
            for (const child of parent.items) {
                const grandchild = _getYAMLProperty(child, inKeyPath)
                const i = grandchild?.items?.findIndex(node =>
                    node.get(into) === _getProperty(existence.json, relationship.removeProperty)
                ) ?? - 1
                if (i > -1) grandchild.delete(i)
            }
        })
    })

    // 5. Create missing existences and pairs
    _traverseYAMLNode(target.contents, null, {
        mergePair: (collection, templateNode) => {
            if (YAML.isMap(collection)) {
                collection.add(templateNode)
            }
        },
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                let [,parent] = collectionStack
                additions?.filter(addition => {
                        if (typeof addition.in === 'string' || Array.isArray(addition.in) && typeof addition.in[0] === 'string') return true
                        const inExistence = Array.isArray(addition.in) ? existenceMap.get(addition.in[0].ref) : existenceMap.get(addition.in.ref)
                        return inExistence?.node === parent
                    })
                    .filter(addition => {
                        const keyPath = typeof addition.in === 'string' ? addition.in : Array.isArray(addition.in) && typeof addition.in[0] === 'string' ? addition.in[0] : addition.in[1]
                        const keys = keyPath.split('.')
                        if (keys.length > collectionStack.length + 1) return
                        if (keys.length > 1) parent = collectionStack[keys.length]
                        return _getYAMLProperty(parent, keyPath) === targetNode
                    })
                    .filter(({ ref }) => {
                        return !existenceMap.get(ref)
                    })
                    .forEach(({ ref, at }) => {
                        const templateNode = templateExistenceMap.get(ref).node
                        at !== undefined ? targetNode.items.splice(at, 0, templateNode) : targetNode.add(templateNode)
                    })
            }
        },
    }, source.contents)

    // 6. Re-validate the existences in the project
    _traverseYAMLNode(target.contents, null, {
        visitMap: (node, index) => {
            _validateWhere(node, existenceMap, index)
        }
    })

    // 7. Create missing relationships
    _traverseYAMLNode(target.contents, null, {
        mergeCollection: (targetNode, templateNode) => {
            if (YAML.isSeq(templateNode)) {
                const targetJSON = YAML.parse(String(targetNode))
                const relationship = semantics.relationships?.filter(r => r)
                    .find(relationship => {
                        const [existence, keyPath] = relationship.into
                        if (!existenceMap.get(existence.ref)) return false
                        const existingNode = _getYAMLProperty(existenceMap.get(existence.ref).node, keyPath)
                        return targetNode === existingNode
                })
                if (!relationship) return

                const intoKey = relationship.into[relationship.into.length - 1]
                const [existence, existenceKeyPath] = relationship.insert
                const missingPairs = [existence]
                    .filter(({ref}) =>
                        !targetJSON.some(item =>
                            _getProperty(existenceMap.get(ref).json, existenceKeyPath) === item[intoKey]
                        )
                    )
                    .map(({ref}) => existenceMap.get(ref).node.get(intoKey))
                missingPairs.forEach(pair => {
                    targetNode.add({ [intoKey]: pair })
                })
            }
        }
    }, source.contents)

    typeof into === 'string' && await writeYAML(into, target)
    return target
}

async function removeFromYAML(name, keyPaths) {
    const yaml = await readYAML(name)
    for (const keyPath of keyPaths) {
        let node = yaml
        const keys = keyPath.split('.')
        for (const [index, key] of keys.entries()) {
            if (index === keys.length - 1) {
                node.delete(key)
            } else {
                node = node.get(key)
            }
        }
    }
    await writeYAML(name, yaml)
}

async function removeFromYAMLArray(name, keyPath, aliasToRemove) {
    const yaml = await readYAML(name)

    let node = yaml
    // traverse to the array node
    const keys = keyPath.split('.')
    for (const key of keys) {
        node = node.get(key)
    }

    // find index of array entry with aliasToRemove entry
    let index = 0;
    let entryNode = node.getIn([index])
    while(entryNode !== undefined) {
        if(entryNode.toJSON().alias === aliasToRemove) {
            node.deleteIn([index])
            break;
        }
        index++;
        entryNode = node.getIn([index])
    }

    await writeYAML(name, yaml)
}

module.exports = {
  sortDependencies,
  mergeJSON,
  mergeYAML,
  removeFromYAML,
  removeFromYAMLArray
}
