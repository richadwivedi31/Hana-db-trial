const path = require('path')
const cds = require('../../cds')
const { BuildTaskFactory } = cds.build
const { read, exists } = cds.utils
const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS
const BUILD_TASK_JAVA = "java"
const BUILD_TASK_JAVA_CF = "java-cf"
const BUILD_TASK_NODEJS = "nodejs"
const BUILD_TASK_NODE_CF = "node-cf"
const BUILD_TASK_HANA = "hana"
const BUILD_TASK_FIORI = "fiori"
const BUILD_TASK_MTX = "mtx"
const BUILD_TASK_MTX_SIDECAR = "mtx-sidecar"
const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) && console.debug
const LOG = console

module.exports = class ProjectReader {

    constructor(projectPath) {
        this.projectPath = projectPath
    }

    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    async getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return cds.env.for('cds', exists(this.projectPath) ? this.projectPath : this.cwd);
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    async read(options) {
        const env = await this.getEnv();
        DEBUG && DEBUG({ env })

        const cap = await this._getCapDescriptor(env, options)
        const ui = await this._getUiDescriptor(env)
        const projectDescriptor = { cap, ui }
        this._validateDbFolders(cap)

        DEBUG && DEBUG({ projectDescriptor })
        return projectDescriptor
    }

    _validateDbFolders(cap) {
        const { root, db: dbs, isJava } = cap
        if (isJava) {
            for (const db of dbs) if (!exists(path.join(root, db.path, 'package.json'))) {
                LOG.error(`Missing 'package.json' in folder ${db.path} - 'cds add hana' adds configuration for SAP HANA`)
            }
        }
    }

    async _getCapDescriptor(env, options) {
        const projectPath = this.projectPath
        const _hasFacet = template => require(`../template/${template}`).hasFacet(env, projectPath, options)
        const cap = {
            for: options?.for,
            pLanguage: DEFAULT_P_LANGUAGE,
            srv: {},
            db: [],
            requires: [],
            get root()           { return projectPath },
            get hasRequires()    { return this.requires.length > 0 },
            get needsSidecar()   { return (options?.add.has('hana') || this.db.length > 0) && (this.isJava || !this.isMultitenant) },
            get isNodejs()       { return this.pLanguage === P_LANGUAGE_NODEJS },
            get isJava()         { return this.pLanguage === P_LANGUAGE_JAVA },
            get isMultitenant()  { return _hasFacet('multitenancy') },
            get isExtensible()   { return _hasFacet('extensibility') },
            get hasHana()        { return _hasFacet('hana') },
            get hasXsuaa()       { return _hasFacet('xsuaa') },
            get hasAuditlog()    { return _hasFacet('auditlog') },
            get hasApprouter()   { return _hasFacet('approuter') },
            get hasMessaging()   { return _hasFacet('enterprise-messaging') },
            get hasDestination() { return _hasFacet('destinations') },
            get hasHtml5Repo()   { return _hasFacet('html5-repo') },
            get hasMta()         { return _hasFacet('mta') },
            get hasHelm()        { return _hasFacet('helm') },
        }

        // setting the effective env as it might have changed by already executed 'add' commands, e.g. cds init foo --add hana,mta
        const cds = require('../../cds')
        cds.env // make sure env is initialized, otherwise we cannot set it (exotic case)
        cds.env = env

        const nullLogger = { debug: () => { }, log: () => { }, warn: () => { }, error: () => { }, write: () => { } }

        // no file path resolving as the directories might not exist - e.g. cds add will create the mtx/sidecar folder
        const buildTasks = await new BuildTaskFactory(nullLogger, cds).getTasks({ root: this.projectPath, resolve: false, mta: false })

        await Promise.all(buildTasks.map(async (task) => {
            const srcPath = path.resolve(this.projectPath, task.src)
            const srcFolder = path.basename(srcPath)
            const relDestPath = path.join(env?.build?.target ?? "gen", task.dest || task.src)?.replace(/\\/g, '/')

            switch (task.for) {
                case BUILD_TASK_HANA:
                    // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
                    if (this._hasHanaServiceBinding(env)) {
                        cap.db.push({ path: relDestPath, name: srcFolder })
                    }
                    break

                case BUILD_TASK_JAVA:
                case BUILD_TASK_JAVA_CF:
                    cap.pLanguage = P_LANGUAGE_JAVA
                    cap.srv = {
                        path: relDestPath,
                        name: srcFolder,
                        ext: await this._getJavaExtDescriptor(srcPath)
                    }
                    break

                case BUILD_TASK_NODEJS:
                case BUILD_TASK_NODE_CF:
                    cap.srv = {
                        path: relDestPath,
                        name: srcFolder
                    }
                    break

                case BUILD_TASK_FIORI:
                case BUILD_TASK_MTX:
                case BUILD_TASK_MTX_SIDECAR:
                    break

                default:
                    LOG.warn(`Unknown build task type ${task.for}`)
            }
        }))

        // setting app name, app description...
        await this._setAppDetails(cap)

        // setting required resource information
        this._setResourceDependencies(env, cap)

        return cap
    }

    /**
     * Determines java specific properties for the given module source path.
     * @param {object} srcPath
     */
    async _getJavaExtDescriptor(srcPath) {
        // by default spring-boot:repackage is used creating an executable jar archive
        const pomJson = await this._parseXml(path.join(srcPath, 'pom.xml'))
        if (pomJson) {
            const dependencies = pomJson?.project?.dependencies?.[0]?.dependency
            const isOldJavaRuntime = [...dependencies].some(d => /com\.sap\.cloud\.servicesdk/.test(d?.groupId?.[0]))
            if (isOldJavaRuntime) {
                throw new Error("Projects using the classic CAP Java SDK are not supported")
            }

            const descriptor = { archiveName: path.basename(this.projectPath) + "-exec.jar" }
            const archiveName = pomJson?.project?.artifactId?.[0]
            const suffix = pomJson?.project?.packaging?.[0]
            if (archiveName) descriptor.archiveName = archiveName + '-exec.' + suffix
            return descriptor
        }
    }

    async _getUiDescriptor(env) {
        const absoluteAppPath = path.join(this.projectPath, env.folders.app)
        return {
            appPath: exists(absoluteAppPath) ? env.folders.app : null
        }
    }

    async _setAppDetails(cap) {
        if (cap.pLanguage !== P_LANGUAGE_JAVA && cap.pLanguage !== P_LANGUAGE_NODEJS) {
            throw Error(`${cap.pLanguage} not supported`)
        }

        // 1.1. java - use parent pom.xml
        if (cap.pLanguage === P_LANGUAGE_JAVA) {
            const pomXmlPath = path.join(this.projectPath, 'pom.xml')
            try {
                if (exists(pomXmlPath)) {
                    const pomJson = await this._parseXml(pomXmlPath)
                    const [artifactId] = pomJson?.project?.artifactId ?? []
                    const [description] = pomJson?.project?.description ?? []
                    let [version] = pomJson?.project?.version ?? []
                    // might need to resolve <version>${revision}</version> property
                    if (version.match(/\${1}\{{1}([\w-\\.]+)\}{1}/)?.length === 2) {
                        version = pomJson?.project?.properties?.[0].revision[0]
                    }
                    if (version) {
                        // check compliance with mta version format - copied from mbt build error message
                        // if not compliant we use a static default value, see below...
                        if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/.test(version)) {
                            cap.appVersion = version
                        }
                    }
                    if (artifactId) {
                        cap.appName = artifactId.split(/-parent/)[0]
                    }
                    if (description) {
                        cap.appDescription = description
                    }
                }
            } catch (e) {
                LOG.error(`Failed to read file ${pomXmlPath} - skip pom.xml data`)
                LOG.error(e)
            }
        }

        // 1.2. use package.json
        if (!cap.appName) {
            const packageJsonPath = path.join(this.projectPath, 'package.json')
            if (exists(packageJsonPath)) {
                try {
                    const { name, version, description } = await read(packageJsonPath)
                    cap.appDescription = cap.appDescription ?? description
                    cap.appVersion = cap.appVersion ?? version
                    if (name) {
                        const segments = name.trim().replace(/@/g, '').split('/').map(encodeURIComponent)
                        cap.appName = cap.appName ?? segments[segments.length - 1]
                        cap.appId = cap.appId ?? segments.join('.')
                        cap.appDescription = cap.appDescription ?? cap.appName
                    }
                } catch (e) {
                    LOG.error(`Failed to read file ${packageJsonPath} - skip application data`)
                    LOG.error(e)
                }
            }
        }

        // 2. use project name and static default values
        cap.appName = cap.appName ?? path.basename(this.projectPath)
        cap.appDescription = cap.appDescription ?? cap.appName + " application"
        cap.appId = cap.appId ?? cap.appName
        cap.appVersion = cap.appVersion ?? '1.0.0'
    }

    _setResourceDependencies(env, cap) {
        for (const [key, require] of Object.entries(env.requires)) {
            if (key === 'sql' || key === 'sqlite' || key === 'hana') continue // ignore abstract helper definitions like sql
            const resource = this._getReqResource(key, require, cap)
            if (resource) cap.requires.push({ resource }) // using production profile
        }
    }

    _hasHanaServiceBinding(env) {
        const db = env?.requires?.db
        return db?.kind === 'hana' || db?.kind === 'sql' && (db?.dialect === 'hana' || db?.use === 'hana')
    }

    _getReqResource(key, reqEntry, cap) {
        const { kind, dialect, use, vcap = {}, multiTenant } = reqEntry
        const { appName, isMultitenant } = cap
        const resource = {
            name: !key.includes(appName) ? `${appName}-${key}` : key,
            service: '',
            vcap,
            get isMultitenant() { return isMultitenant || multiTenant || false },
            get isManagedHana() { return this.vcap.label === 'service-manager' || this.service === 'service-manager' },
            get isPlainHana()   { return this.service === 'hana' && !this.isManagedHana },
            get isHana()        { return this.isPlainHana || this.isManagedHana },
            get isXsuaa()       { return this.service === 'xsuaa' },
        }

        switch (kind) {
            case 'sql':
            case 'hana':
                if (kind === 'sql' && dialect !== 'hana' && use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultitenant) {
                    resource.service = 'service-manager'
                    resource.vcap.plan = 'container'
                } else {
                    resource.service = 'hana'
                    resource.vcap.plan = 'hdi-shared'
                }
                break

            case 'xsuaa':
                resource.service = kind
                resource.vcap.plan = 'application'
                break
            default: {
                vcap.plan ? resource.service = kind : DEBUG && DEBUG(`Skip resource ${key}`)
            }
        }
        return resource.service ? resource : null
    }

    /**
     * Parse a given string containing xml
     * used to remove the _text object from converted json i.e. from xml-js.
     * example : converted json has "groupId":[{"_text":["customer"]}]
     * and after removing textAttributes (using this function): "groupId":["customer"]
     * @param xml string to parse
     * @returns parsed json object
     */
    async _parseXml(pomXmlPath) {
        const xmljs = require('xml-js');
        let xmljsParse = {};
        try {
            const xml = await read(pomXmlPath, 'utf-8')
            xmljsParse.project = JSON.parse(await xmljs.xml2json(xml, {
                ignoreComment: true,
                compact: true,
                alwaysArray: true,
                ignoreDeclaration: true,
                attributesKey: "$",
                trim: true,
                nativeType: true,
                ignoreInstruction: true,
                ignoreCdata: true,
                ignoreDoctype: true,
                textFn: this._removeTextAttributes
            })).project[0];
            return xmljsParse;
        } catch (e) {
            LOG.error(`Failed to read file ${pomXmlPath} - skip pom.xml data`)
            LOG.error(e)
        }
    }

    /*
        Remove the _text attributes and convert value it into array
        input : "groupId":[{"_text":["customer"]}]
        output: "groupId":["customer"]
    */
    _removeTextAttributes(value, parentElement) {
        const parentKeys = Object.keys(parentElement._parent);
        const key = parentKeys[parentKeys.length - 1];
        const _text = parentElement._parent[key];
        if (_text.length > 0) {
            _text[_text.length - 1] = value;
        } else {
            parentElement._parent[key] = value;
        }
    }
}
