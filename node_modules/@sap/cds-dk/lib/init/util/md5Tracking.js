const path = require('path'), { dirname, resolve } = path;
const { mkdirp, isdir } = require('../../cds').utils;
const cds = require('../../cds');

const fs = require('fs');
const crypto = require('crypto');
const LOG = cds.log('k8s');
const os = require('os');

async function copyAndTrack(source, dest, context = {}, force = false) {
    const sourcePath = resolve(cds.root, source);
    const destPath = resolve(cds.root, dest);
    //if (fs.promises.cp) return fs.promises.cp(src, dst, { recursive: true });
    await mkdirp(dirname(destPath));
    if (isdir(sourcePath)) {
        const entries = await fs.promises.readdir(sourcePath);
        return Promise.all(entries.map(async each => {
            const subSourcePath = path.join(sourcePath, each);
            const subDestPath = path.join(destPath, each);
            return copyAndTrack(subSourcePath, subDestPath, context);
        }))
    } else {
        let data = await _readFileIfExists(sourcePath, 'utf-8');
        if (!force && await _isChartFileModified(destPath, context)) {
            LOG.warn("Chart file " + destPath + " has been modified and will not be updated.");
        } else {
            _track(destPath, data, context);
            return fs.promises.copyFile(sourcePath, destPath);
        }
    }
}


/**
* Takes path of md5 file as an argument and returns a JSON object containing hashes of files stored in MD5 file.
* @param {String} path
* @returns {Promise<JSON>}
*/
async function parseMd5File(path) {
    let md5Hashes = {};
    const md5FileContent = await _readFileIfExists(path);
    if (md5FileContent == undefined) return md5Hashes;
    let md5Checksums = md5FileContent.toString().split(os.EOL)
    md5Checksums.forEach((checksum) => {
        checksum = checksum.split(" ")
        md5Hashes[checksum[1]] = checksum[0];
    })
    return md5Hashes;
}

/**
* Takes json object containing key as filename and value as MD5 hash and generates a md5sum format file.
* @param {String} path
* @param {Promise<JSON>} data
*/
async function writeMd5File(path, data) {
    let md5_output;
    Object.keys(data).forEach(key => {
        var currMd5 = `${data[key]} ${key}`;
        if (md5_output === undefined)
            md5_output = currMd5;
        else
            md5_output += os.EOL + currMd5;
    })
    await fs.promises.writeFile(path, md5_output);
}

async function _readFileIfExists(path, encoding) {
    try {
        return await fs.promises.readFile(path, encoding);
    } catch (error) {
        if (error.code === 'ENOENT' || error.code === 'EISDIR') return undefined;
        else throw error;
    }
}

async function _isChartFileModified(filePath, context = {}) {
    const data = await _readFileIfExists(filePath, 'utf-8');
    if (data == undefined) {
        return false;
    }

    const key = _pathKey(path.join(context.projectPath, 'chart'), filePath);
    const currentHash = _hash(data);
    return context.oldTrackingData != undefined && context.oldTrackingData[key] != undefined && context.oldTrackingData[key] != currentHash;
}

function _hash(data) {
    return crypto.createHash('md5').update(data).digest('base64');
}

function _pathKey(basePath, cPath) {
    return path.posix.normalize(_toPosix(path.relative(basePath, cPath)))
}

function _toPosix(path) {
    return path.replace(/\\/g, '/');
}

async function _track(filePath, data, context = {}) {
    const key = _pathKey(path.join(context.projectPath, 'chart'), filePath);
    const hashedContent = _hash(data);
    if (context.oldTrackingData != undefined && context.oldTrackingData[key] != undefined) {
        context.oldTrackingData[key] = hashedContent;
    }
    context.newTrackingData[key] = hashedContent;
}

module.exports = {
    copyAndTrack,
    parseMd5File,
    writeMd5File
}