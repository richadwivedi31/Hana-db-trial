const cp = require('child_process');
const fsp = require('fs').promises;
const os = require('os');
const util = require('util');

const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG) && console.debug

const axios = require('axios');
const { URL } = require('url');
const path = require('path');
const { bold, highlight } = require('../util/term');
const { CliError } = require('../client/helper/errors');

const execAsync = util.promisify(cp.exec);
const IS_WIN = os.platform() === 'win32';

class CFKeyProvider {
    async _cfRead(...args) {
        DEBUG && DEBUG(`_cfRead: cf ${args}`);

        const result = await execAsync(`cf ${args}`, {
            shell: IS_WIN,
            stdio: ['inherit', 'pipe', 'inherit'],
        });

        return result.stdout.toString().trim();
    }

    extract(string, pattern, errorMsg) {
        const match = string.match(pattern);
        if (!match || !match[1]) {
            throw new Error(errorMsg);
        }
        return match[1];
    }

    async getCfTargetFromConfigFile() {
        const cfHome = process.env.CF_HOME || process.env.cf_home || path.join(os.homedir(), '.cf');
        try {
            const fileContent = await fsp.readFile(path.join(cfHome, 'config.json'));
            const config = JSON.parse(fileContent);
            if (config) {
                return {
                    apiEndpoint: this.extract(config.Target, /\s*(.+)\s*/, `CF API endpoint is missing. Use 'cf login' to login.`),
                    org: this.extract(config.OrganizationFields.Name, /\s*(.+)\s*/, `CF org is missing. Use 'cf target -o <ORG> to specify.`),
                    space: this.extract(config.SpaceFields.Name, /\s*(.+)\s*/, `CF space is missing. Use 'cf target -s <SPACE>' to specify.`)
                }
            }
        } catch (err) {
            DEBUG && DEBUG(`getCfTargetFromConfigFile: ${err}`);
        }
    }

    async getCfTargetFromCli() {
        const result = await this._cfRead('target');
        return {
            apiEndpoint: this.extract(result, /api endpoint\s*:\s*([^\s]+)/i, `CF API endpoint is missing. Use 'cf login' to login.`),
            user: this.extract(result, /user\s*:\s*(.+)/i, `CF user is missing. Use 'cf login' to login.`),
            org: this.extract(result, /org\s*:\s*(.+)/i, `CF org is missing. Use 'cf target -o <ORG> to specify.`),
            space: this.extract(result, /space\s*:\s*(.+)/i, `CF space is missing. Use 'cf target -s <SPACE>' to specify.`),
        };
    }

    async getCfTarget() {
        return await this.getCfTargetFromConfigFile() || await this.getCfTargetFromCli();
    }

    async getCfSpaceInfo() {
        DEBUG && DEBUG('getting space info');

        const target = await this.getCfTarget();
        const authorization = await this.getCfAuthorization();
        const targetWithAuth = Object.assign({}, target, { authorization });


        const { org, space } = target;
        const orgs = await BatchRequest.req(targetWithAuth, `/v3/organizations?names=${encodeURIComponent(encodeURIComponent(org))}`);
        if (!(orgs && orgs.resources.length === 1)) {
            throw new Error(`CF org ${org} not found!`);
        }

        const orgGuid = orgs.resources[0].guid;
        const spaces = await BatchRequest.req(targetWithAuth, `/v3/spaces?names=${encodeURIComponent(encodeURIComponent(space))}&organization_guids=${encodeURIComponent(encodeURIComponent(orgGuid))}`)
        if (!(spaces && spaces.resources.length === 1)) {
            throw new Error(`CF space ${space} not found in org ${org}!`);
        }

        const spaceGuid = spaces.resources[0].guid;

        return Object.assign({}, target, { orgGuid, spaceGuid, authorization });
    }

    async getCfAuthorization() {
        DEBUG && DEBUG('getting authorization');
        return this._cfRead('oauth-token');
    }

    async init() {
        const target = this.target = await this.getCfSpaceInfo();
        this.getOrg = BatchRequest.create({ target, url: '/v3/organizations' });
        this.getSpace = BatchRequest.create({
            target, url: '/v3/spaces', extractors: {
                organization_guids: resource => resource.relationships.organization.data.guid
            }
        });
        this.getInstance = BatchRequest.create({
            target, url: '/v3/service_instances', extractors: {
                space_guids: resource => resource.relationships.space.data.guid
            }
        });
        this.getKey = BatchRequest.create({
            target, url: '/v3/service_credential_bindings', extractors: {
                service_instance_guids: resource => resource.relationships.service_instance.data.guid
            }
        });
        this.getPlans = BatchRequest.create({ target, url: '/v3/service_plans' });
        this.getOfferings = BatchRequest.create({ target, url: '/v3/service_offerings' });
    }

    async resolve(name, binding) {
        if (!this.initPromise) {
            this.initPromise = this.init();
        }
        await this.initPromise;
        this._checkApiEndpoint(name, binding)

        let { instance, org, space } = binding;
        let spaceGuid;
        if (org && space) {
            // org and space can be overwritten by currently logged in org and space
            const orgObj = await this.getOrg({ names: org });
            const spaceObj = await this.getSpace({ names: space, organization_guids: orgObj.guid });
            spaceGuid = spaceObj.guid;
        } else {
            org = this.target.org;
            space = this.target.space;
            spaceGuid = this.target.spaceGuid;
        }

        let instanceObj;
        try {
            instanceObj = await this.getInstance({ names: instance, space_guids: spaceGuid });
        } catch (error) {
            throw new Error(`Service instance "${instance}" not found.`);
        }
        switch (instanceObj.type) {
            case 'managed':
                return this._resolveManagedService(instanceObj, instance, binding.key || `${instance}-key`, org, space);
            case 'user-provided':
                return this._resolveUserProvidedService(instanceObj, instance, org, space);
            default:
                throw new Error(`Service type ${instanceObj.type} not supported`)
        }
    }

    async _resolveManagedService(instanceObj, instance, key, org, space) {
        let keyObj
        try {
            keyObj = await this.getKey({ names: key, service_instance_guids: instanceObj.guid });
        } catch (error) {
            let message = `No service key ${highlight(key)} found for service instance ${highlight(instance)}.\n\n`;
            message += `Use ${bold(`cf create-service-key ${instanceObj.name} ${key} [-c ...]`)} to create the required service key.`;
            throw new CliError(message);
        }
        const planObj = await this.getPlans({ guids: instanceObj.relationships.service_plan.data.guid });
        const offeringObj = await this.getOfferings({ guids: planObj.relationships.service_offering.data.guid });
        const keyCredentialsObj = await BatchRequest.req(this.target, `/v3/service_credential_bindings/${encodeURIComponent(keyObj.guid)}/details`);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                key: key,
                vcap: {
                    label: offeringObj.name,
                    plan: planObj.name,
                    tags: offeringObj.tags
                },
                resolved: true,
            },
            credentials: keyCredentialsObj.credentials
        };

        return resolvedBinding;
    }

    async _resolveUserProvidedService(instanceObj, instance, org, space) {
        const credentialsObj = await BatchRequest.req(this.target, `/v3/service_instances/${encodeURIComponent(instanceObj.guid)}/credentials`);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: this.target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                vcap: {
                    label: instanceObj.type,
                    tags: instanceObj.tags
                },
                resolved: true,
            },
            credentials: credentialsObj
        };
        return resolvedBinding;
    }

    _checkApiEndpoint(name, binding) {
        const { apiEndpoint, key, instance } = binding

        // if no api endpoint is configured the currently logged in endpoint will be used
        if (apiEndpoint && apiEndpoint !== this.target.apiEndpoint) {
            name = `${name || instance}:${key || instance + '-key'}`
            let message = `Current Cloud Foundry API endpoint ${highlight(this.target.apiEndpoint)} differs from API endpoint ${highlight(apiEndpoint)} for service binding ${highlight(name)}.\n\n`;
            message += `Use ${bold(`cf login -a ${apiEndpoint}`)} to log in to the target API endpoint.`;
            throw new CliError(message)
        }
    }
}

class BatchRequest {
    constructor({ target, url, extractors = {} }) {
        this.target = target;
        this.url = url;
        this.filters = [];
        this.timeout = undefined;
        this.extractors = Object.assign({ names: resource => resource.name, guids: resource => resource.guid }, extractors);
    }

    static create(options) {
        const obj = new BatchRequest(options);
        return (...args) => obj.request(...args);
    }

    async request(filter) {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        this.filters.push({ filter, resolve, reject });

        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.executeRequest(), 0);

        return promise;
    }

    async executeRequest() {
        const filters = this.filters;
        this.filters = [];
        const filterParams = {};
        for (const filter of filters) {
            for (const name of Object.keys(filter.filter)) {
                if (!filterParams[name]) filterParams[name] = [];
                filterParams[name].push(filter.filter[name]);
            }
        }

        const params = Object.keys(filterParams).map(
            name => `${name}=${encodeURIComponent(filterParams[name].map(encodeURIComponent).join(','))}`
        ).join("&");

        const url = this.url + (this.url.match(/\?/) ? '&' : '?') + params;

        let data;
        try {
            data = await this.httpRequest(url);
        } catch (error) {
            for (const filter of filters) {
                filter.reject(error);
            }
            return;
        }
        const fmt = filter => Object.keys(filter).map(key => `${key}: ${filter[key]}`).join(', ');
        const resources = data.resources;
        for (const filter of filters) {
            let filteredResources = resources;
            for (const name of Object.keys(filter.filter)) {
                filteredResources = filteredResources.filter(resource => this.extractors[name](resource) === filter.filter[name]);
            }
            if (filteredResources.length === 1) {
                filter.resolve(filteredResources[0]);
            } else if (filteredResources.length === 0) {
                filter.reject(new Error(`Couldn't find resource for url "${this.url}" with filter "${fmt(filter.filter)}"`));
            } else {
                filter.reject(new Error(`Found more than one resources for url "${this.url}" with filter "${fmt(filter.filter)}"`));
            }
        }
    }

    async httpRequest(urlPath) {
        return BatchRequest.req(this.target, urlPath);
    }

    static async req(target, urlPath) {
        const url = new URL(urlPath, target.apiEndpoint);
        DEBUG && DEBUG(`_req: ${url.toString()}`);

        const result = await axios.get(url.toString(), {
            headers: {
                authorization: target.authorization
            }
        });
        return result.data;
    }
}

module.exports = new CFKeyProvider()
