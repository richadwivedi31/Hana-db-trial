const os = require('os');
const path = require('path');
const readline = require('readline');

const DEBUG = /\b(y|all|cli)\b/.test(process.env.DEBUG)  && console.debug

const fs = require('fs').promises;
const { highlight } = require('../util/term');
const { logger } = require('./bindingUtil')

const commandUtil = require('../init/util/commandUtil');

const CDSRC_FILENAME = '.cdsrc-private.json';
const GIT_IGNORE_FILE = '.gitignore';

class UserCdsrcJsonStorageProvider {
    async askBooleanQuestion(question) {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        question = question.trim() + ' ';
        return new Promise(resolve => {
            rl.question(question, answer => {
                if (answer === 'y' || answer === 'Y') {
                    resolve(true);
                } else {
                    resolve(false);
                }
                rl.close();
            });
        });
    }

    async ensureFileIsGitignored(file) {
        try {
            await commandUtil.spawnCommand('git', ['check-ignore', '-n', '-v', file], {}, undefined, true);
            return; // file is git ignored
        } catch (err) {
            if (err.code === 'ENOENT') {   // git command not found
                DEBUG && DEBUG('git command not found');
                return;
            }

            if (!err.stdLog.match(/::/)) {   // included or not a git repo
                DEBUG && DEBUG(err);
                return;
            }
        }

        logger.log(`adding entry '${file}' to ${GIT_IGNORE_FILE}.`);
        let gitignore = await this.readFileSafely(GIT_IGNORE_FILE);
        gitignore = gitignore + `
# added by cds bind
${file}
`;
        await fs.writeFile(GIT_IGNORE_FILE, gitignore, 'utf8');
    }

    async readFileSafely(file) {
        try {
            return await fs.readFile(file, 'utf8');
        } catch (err) {
            return '';
        }
    }

    async storeServices(services, options = {}) {
        let jsonPath = options['output-file'] || CDSRC_FILENAME;

        if (jsonPath === CDSRC_FILENAME) {
            await this.ensureFileIsGitignored(CDSRC_FILENAME);
        }

        jsonPath = jsonPath.replace(/~/g, os.homedir());
        // const stat = await .stat(jsonPath);
        if (path.extname(jsonPath) !== '.json') {
            jsonPath = path.join(jsonPath, '.cdsrc.json');
        }

        const jsonObject = await this.readJsonSafely(jsonPath);
        let cdsRoot;
        if (path.basename(jsonPath) === 'package.json') {
            jsonObject.cds = jsonObject.cds || {};
            cdsRoot = jsonObject.cds;
        } else {
            cdsRoot = jsonObject;
        }

        const profileKey = `[${options.profile}]`;
        const features = cdsRoot.features && cdsRoot.features[profileKey];
        if (features) delete features.emulate_vcap_services;

        cdsRoot.requires = cdsRoot.requires || {};
        let section;
        if (options.profile) {
            section = cdsRoot.requires[profileKey] = cdsRoot.requires[profileKey] || {};
        } else {
            section = cdsRoot.requires;
        }

        for (const service of services) {
            const { name, kind, binding, credentials } = service;
            const requireService = section[name] = section[name] || {};

            Object.assign(requireService, { binding: { ...binding, vcap: undefined }, credentials, kind, vcap: { name } });
        }

        await this.writeJsonFile(jsonPath, jsonObject);
        if (options.profile) {
            logger.log(`Saving bindings to ${highlight(jsonPath)} in profile ${highlight(options.profile)}`);
        } else {
            logger.log(`Saving bindings to ${highlight(jsonPath)}`);
        }
    }

    async readJsonSafely(filePath) {
        try {
            return JSON.parse(await fs.readFile(filePath));
        } catch (err) {
            return {};
        }
    }

    async writeJsonFile(filePath, content) {
        await fs.mkdir(path.dirname(filePath), { recursive: true })
        await fs.writeFile(filePath, JSON.stringify(content, null, 2));
        await fs.chmod(filePath, 0o600); // -rw-------
    }
}

module.exports = new UserCdsrcJsonStorageProvider();
